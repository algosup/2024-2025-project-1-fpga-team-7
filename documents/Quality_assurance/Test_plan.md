# Test Plan 

| Author        | Paul NOWAK (Q.A.) |
|---------------|------------|
| Created       | 09/28/2024 |
| Last Modified | 10/21/2024 |
| Number of Test Cases written| 110 |
| Number of Test Cases completed| 86 |
| Document Deadline | 10/21/2024 |

---

<details>

<summary>ðŸ“– Table of content</summary>

- [Introduction](#introduction)
- [1. Objectives](#1-objectives)
- [2. Testing Strategy](#2-testing-strategy)
  - [2-1 Functional Testing](#2-1-functional-testing)
  - [2-2 Performance Testing](#2-2-performance-testing)
  - [2-3 Stress Testing](#2-3-stress-testing)
  - [2-4 Hardware Testing](#2-4-hardware-testing)
  - [2-5 User Interface Testing](#2-5-user-interface-testing)
  - [2-6 Regression Testing](#2-6-regression-testing)
- [3. Features to test](#3-features-to-test)
  - [3-1 Functional Testing](#3-1-functional-testing)
  - [3-2 Performance Testing](#3-2-performance-testing)
  - [3-3 Stress Testing](#3-3-stress-testing)
  - [3-4 Hardware Testing](#3-4-hardware-testing)
  - [3-5 User Interface Testing](#3-5-user-interface-testing)
  - [3-6 Regression Testing](#3-6-regression-testing)
- [4. Features to not test](#4-features-to-not-test)
- [5. Hardware Requirements](#5-hardware-requirements)
- [6. Environment Requirements](#6-environment-requirements)
- [7. Problem Reporting](#7-problem-reporting)
- [8. Risks & Assumptions](#8-risks--assumptions)
- [9. Approvals](#9-approvals)

</details>

---

## Introduction

The purpose of this document is to outline the testing strategy aimed at ensuring the functionality, quality, and performance of the Frogger game, developed for the FPGA module. 

The test plan covers a broad range of scenarios, including hardware, software, and user interface components. Our primary objective is to verify that the game meets the defined requirements, operates smoothly under various conditions, and maintains high performance throughout gameplay.

This document will also enumerate the test cases required to cover these areas, detailing both functional and performance tests to ensure the Frogger game performs optimally on the FPGA platform.

## 1. Objectives 

The goal of this project is to program a version of the famous game Frogger: it's a game where we play a frog attempting to cross a road and a river to join his home, and who must avoid certain obstacles like cars while trying to get the highest score possible.

Furthermore, the main difficulty is to program this game for an FPGA module, using the Verilog programming language. Indeed, we will need to program the game while testing it on the FPGA module and checking its performance.

Concerning the game rules:
- The frog must reach the end of the road to go to the next level, where he will be teleported back to its starting location. The player gets points after each level passed.
- The player must use the different switch buttons from the FPGA module to progress through the game: Left, Right, Up and Down.
- The player must avoid the moving car which came from the right and the left, while crossing through the different lanes.
- As the player increase through the levels (each 3 levels), the difficulty will increase with the acceleration of the moving cars.
- If the player collides with a car, it will trigger a death and he will be teleported back to the level at the starting point.
- The player has 3 lives: if he lost all of them, the frog will be teleported back to the level 1 and the player will need to push all 4 buttons simultaneously to restart the game.

The project must be completed for October 21th 2024.

## 2. Testing Strategy
The test cases will be separated in 6 different domain of testing. Indeed, we want to check each type individually to ensure their performance before testing the cases together.

### 2-1 Functional Testing
Probably the most important, this first type of testing concerns the game logic: its goal is to ensure the game's functions work correctly, such as the player movements, the collisions and the reset conditions.

The testing will be executed by the Q.A., with the possible assistance of the Software Engineers and the Program Manager. In fact, the test cases will be accomplished in a way the tester is currently playing the game.

### 2-2 Performance Testing
This testing deals about the clock timing, where the game logic follows the clock cycle allowed by the FPGA module. Furthermore, it will allow to measure the latency and the refresh rate of the game.

The Q.A. and the Tech Lead will be the involved testers, where various software tools could be required to measure the performance. In reality, the goal will be to test the game by monitoring the player's actions and the game's responses.

### 2-3 Stress Testing
Stress Testing is particular, because it involves inconsistent conditions such as simulating multiple inputs or slow loading conditions.

The Q.A., possibly accompanied by the Software Engineers and the Tech Lead, will work on that type of testing. For that, they will pretend to play the game "agressively" and use a software to simulate a slow latency.

### 2-4 Hardware Testing
This one will be required because it's focused on the use of the FPGA module. Indeed, we will have to make sure the module will handle the required program of the game, that its components like switches and lead still work, and potentially display the level number on his LCD screen.

The Q.A. will work on that testing with the assistance of the Tech Lead, where they will test various programs to ensure the hardware performance of the FPGA module.

### 2-5 User Interface Testing
User Interface Testing, as its name implies, deals with the interaction between the user and the game's interface. Indeed, it will test if the games responds well to the player's inputs and if the game's screen displays correctly on a monitor or another device.

Once again, the Q.A. will be in charge of the test, but with the possible assistance of the Software Engineers and the Program Manager. For that, they will execute various inputs with the keyboard and monitor differents screen settings to visualize the game.

### 2-6 Regression Testing
Finally, Regression Testing should be done after one or several others types of testing have been tested. Indeed, bugs will potentially appear, and after fixing them, there is a huge chance we will have to execute the previous test cases again to ensure their functionnality.

Every involved testers from previous testings, led by the Q.A., will be in charge with the previous rules decided for each testing.

## 3. Features to test

### 3-1 Functional Testing

#### Frogger
| Test Name | Description | Number of steps |    Steps list     |    Expected    |       Got       |       Priority       | 
| --------- | ----------------- | -------------------- |    ---------------     |    --------    |       ---       |       ---       | 
| Frog Generation | Ensures to generate the Frog at his starting point on the screen.| 3 |    1. Start the game. <br /> 2. Set a generateFrogger() signal. <br /> 3. Wait for a few clock cycles to allow the frog's generation. <br />  |    Frogger is generated at his starting point.    |     âœ…       |     High     |
| Frog Length Movement | We set a movement input signal to make the frog move from 1 tile to another.| 5 |    1. Start the game. <br />  2. Set a generateFrogger() signal.  <br /> 3. Wait for a few clock cycles to allow the frog's generation. <br /> 4.Set a movement input signal. <br /> 5. Wait for a few clock cycles to allow frog's movement. <br />  |    The frog's moves by only 1 tile.    |     âœ…       |     High     |
| Right Movement | We set a movement input signal  to make the frog go to the Right.| 5 |    1. Start the game <br />  2. Set a generateFrogger() signal.  <br /> 3. Wait for a few clock cycles to allow the frog's generation. <br /> 4. Set the Right Key input signal.<br /> 5. Wait for a few clock cycles to allow frog's movement.  |    The frog's moves 1 tile on the Right.    |     âœ…       |     High     |
| Left Movement | We set a movement input signal to make the frog go to the Left.| 5 |    1. Start the game <br />  2. Set a generateFrogger() signal.  <br /> 3. Wait for a few clock cycles to allow the frog's generation. <br /> 4. Set the Left Key input signal. <br /> 5. Wait for a few clock cycles to allow frog's movement.  |    The frog's moves 1 tile on the Left.    |     âœ…       |     High     |
| Up Movement | We set a movement input signal to make the frog go Up.| 5 |    1. Start the game <br />  2. Set a generateFrogger() signal.  <br /> 3. Wait for a few clock cycles to allow the frog's generation. <br /> 4. Set the Up Key input signal. <br /> 5. Wait for a few clock cycles to allow frog's movement. |    The frog's moves 1 tile upwards.    |     âœ…      |     High     |
| Down Movement | We set a movement input signal to make the frog go to the Right.| 5 |    1. Start the game <br />  2. Set a generateFrogger() signal.  <br /> 3. Wait for a few clock cycles to allow the frog's generation. <br /> 4. Set the Down Key input signal.  <br /> 5. Wait for a few clock cycles to allow frog's movement.  |    The frog's moves 1 tile downwards.    |     âœ…     |     High     |
| Sprite Rotation | We set a movement input signal different from the actual frog's direction to make him turn.| 5 |    1. Start the game <br />  2. Set a generateFrogger() signal.  <br /> 3. Wait for a few clock cycles to allow the frog's generation. <br /> 4. Set a movement input signal different from the frog's actual direction.  <br /> 5. Wait for a few clock cycles to allow frog's movement.  |    The frog's sprite is rotated in the same direction than the last movement input.    |      âœ…       |     Medium     |
| Walking Animation | We set a movement input signal to play the frog's walking animation.| 6 |    1. Start the game <br />  2. Set a generateFrogger() signal.  <br /> 3. Wait for a few clock cycles to allow the frog's generation. <br /> 4. Set any movement input signal.  <br /> 5. Wait for a few clock cycles to allow frog's movement. <br /> 6. Monitor the frog's sprite behavior while the playWalkingAnimation() signal is triggered. |    The frog's moving animation is triggered.    |     TO BE TESTED.       |     Low     |

#### Cars

| Test Name | Description | Number of steps |    Steps list     |    Expected    |       Got       |       Priority       | 
| --------- | ----------------- | -------------------- |    ---------------     |    --------    |       ---       |       ---       | 
| Single Car | There should be at least on car appearing on the screen.| 3 |    1. Start the game <br /> 2. Set a generateCar() signal.  <br /> 3. Wait for a few clock cycles to allow car generation. |    A car sprite appears on the road, within 1-2 seconds of setting generateCar().   |     âœ…       |     High     |
| Left Movement | A car moves to the left throughout a lane.| 5 |    1. Start the game <br /> 2. Set a generateCar() signal.  <br /> 3. Wait for a few clock cycles to allow car generation. <br /> 4. Set the moveCarLeft() signal. <br /> 5. Wait for a few clock cycles to allow car movement. |    A car sprite appears on the screen, within 1-2 seconds of setting generateCar(), starts moving left, and passes through its lane smoothly.   |     âœ…      |     High     |
| Right Movement | A car moves to the right throughout a lane.| 5 |    1. Start the game <br /> 2. Set a generateCar() signal.  <br /> 3. Wait for a few clock cycles to allow car generation. <br /> 4. Set the moveCarRight() signal. <br /> 5. Wait for a few clock cycles to allow car movement. |    A car sprite appears on the screen, within 1-2 seconds of setting generateCar(), starts moving right, and passes through its lane smoothly.      |     âœ…       |     High     |
| Driving Left Animation | We ensure the car's driving animation occurs when it is moving left.| 6 |    1. Start the game <br /> 2. Set a generateCar() signal.  <br /> 3. Wait for a few clock cycles to allow car generation. <br /> 4. Set the moveCarLeft() signal. <br /> 5. Wait for a few clock cycles to allow car movement. <br /> 6. Monitor the car's sprite behavior while the playDrivingAnimation() signal is triggered. |    The car's driving animation is triggered while moving to the left.    |     TO BE TESTED.       |     Low     |
| Driving Right Animation | We ensure the car's driving animation occurs when it is moving right.| 6 |    1. Start the game <br /> 2. Set a generateCar() signal.  <br /> 3. Wait for a few clock cycles to allow car generation. <br /> 4. Set the moveCarRight() signal. <br /> 5. Wait for a few clock cycles to allow car movement. <br /> 6. Monitor the car's sprite behavior while the playDrivingAnimation() signal is triggered. |    The car's driving animation is triggered while moving to the right.    |     TO BE TESTED.       |     Low     |
| Car Rotation | A car's sprite is rotated on the right or left depending on its movement.| 5 |    1. Start the game <br /> 2. Set a generateCar() signal.  <br /> 3. Wait for a few clock cycles to allow car generation. 4. Set a car movement input signal.  5. Wait for a few clock cycles to allow car movement.  |    A car sprite appears on the road, within 1-2 seconds of setting generateCar(), and its sprite is rotated in the same direction than its actual movement.   |     âœ…     |     High     |
| Car Right Generation | A car appears from the right side of the road and moves to the left throughout a lane.| 5 |    1. Start the game <br /> 2. Set a generateCarFromRight() signal.  <br /> 3. Wait for a few clock cycles to allow car generation. <br /> 4. Set the moveCarLeft() signal. <br /> 5. Wait for a few clock cycles to allow car movement. |    A car sprite progressively appears from the right of the screen, within 1-2 seconds of setting generateCarFromRight(), starts moving left, and passes through its lane smoothly.   |     âœ…      |     Medium     |
| Car Left Generation | A car appears from the left side of the road and moves to the right throughout a lane.| 5 |    1. Start the game <br /> 2. Set a generateCarFromLeft() signal.  <br /> 3. Wait for a few clock cycles to allow car generation. <br /> 4. Set the moveCarRight() signal. <br /> 5. Wait for a few clock cycles to allow car movement. |    A car sprite progressively appears from the left of the screen, within 1-2 seconds of setting generateCarFromLeft(), starts moving right, and passes through its lane smoothly.   |     âœ…      |     Medium     |
| Car Random Generation| Ensure a car can be randomly generated in a range of locations within a lane, even at both left and right edges.| 8 |    1. Start the game <br /> 2. Set a generateCar() signal.  <br /> 3. Wait for a few clock cycles to allow car generation. <br /> 4. Monitor the location of the car's first appearance and check if its located within the range. <br /> 5. Trigger all movement signals to restart the game. <br /> 6. Make sure the all signals last for at least 2 seconds. <br /> 7. Check if the level 1 has been restarted. <br /> 8. Repeat steps 2-7 several times and make sure the previous car disappeared and replaced by another car at a random location. |    Each time the player start the level, the car is always generated at a location of a lane within the designated range.   |     NOT VALIDATED       |     Medium     |
| Car Left Disappearance | A moving car from the right progressively disappears when it reaches the left side of the screen.| 8 |    1. Start the game.<br /> 2. Set the generateCarFromRight() signal.<br /> 3. Wait for a few clock cycles to allow car generation.<br /> 4. Set the moveCarLeft() signal.<br /> 5. Wait for a few clock cycles to allow car movement.<br /> 6. Wait until the car reaches the left screen edge.<br /> 7. Set the disappearCarOnLeft() signal.<br /> 8. Wait for a few clock cycles to allow car disappearance. <br /> |    The car sprite fades or shrinks progressively until it disappears off the left side of the screen. The movement and disappearance should occur smoothly, within 1-2 seconds.   |     âœ…       |     Medium     |
| Car Right Disappearance | A moving car from the left progressively disappears when it reaches the right side of the screen.| 8 |    1. Start the game.<br /> 2. Set the generateCarFromLeft() signal.<br /> 3. Wait for a few clock cycles to allow car generation.<br /> 4. Set the moveCarRight() signal.<br /> 5. Wait for a few clock cycles to allow car movement.<br /> 6. Wait until the car reaches the right screen edge.<br /> 7. Set the disappearCarOnRight() signal.<br /> 8. Wait for a few clock cycles to allow car disappearance. <br /> |    The car sprite fades or shrinks progressively until it disappears off the right side of the screen. The movement and disappearance should occur smoothly, within 1-2 seconds.   |    âœ…       |     Medium     |
| Set Car speed | Permit to set a different speed to a moving car.| 6 |    1. Start the game <br /> 2. Set a generateCar() signal.  <br /> 3. Wait for a few clock cycles to allow car generation. 4. Set the movingCar() signal. 5. Set the sprite speed. 6. Wait for a few clock cycles to allow car movement. |    A car sprite appears on the road, within 1-2 seconds of setting generateCar(), and moves at the set speed.   |    âœ…      |     High     |
| Increase Car Speed | Increases the speed of a moving car.| 7 |    1. Start the game <br /> 2. Set a generateCar() signal.  <br /> 3. Wait for a few clock cycles to allow car generation. 4. Set the movingCar() signal. 5. Wait for a few clock cycles to allow car movement. 6. Set the increaseCarSpeed() signal.  7. Wait for a few clock cycles to allow speed increase. |    A car sprite appears on the road, within 1-2 seconds of setting generateCar(), and its speed is slightly increased.   |     âœ…       |     Medium     |

#### Collision

| Test Name | Description | Number of steps |    Steps list     |    Expected    |       Got       |       Priority       | 
| --------- | ----------------- | -------------------- |    ---------------     |    --------    |       ---       |       ---       | 
| Car Left Collision with Frog | Detects a collision between a car (from the left) and the frog.| 7 |    1. Start the game.<br /> 2. Generate the frog.<br /> 3. Wait for a few clock cycles to allow the frog to appear.<br /> 4. Set the generateCar() signal.<br /> 5. Wait for car generation.<br /> 6. Makes the car move right. <br /> 7. Move the frog into the carâ€™s path until they collide. <br />  |    The game triggers a car_Frog_Collision() signal when the frog collides with the car which came from the left.   |     âœ…      |     High     |
| Car Right Collision with Frog | Detects a collision between a car (from the right) and the frog.| 7 |    1. Start the game.<br /> 2. Generate the frog.<br /> 3. Wait for a few clock cycles to allow the frog to appear.<br /> 4. Set the generateCar() signal.<br /> 5. Wait for car generation.<br /> 6. Makes the car move left. <br /> 7. Move the frog into the carâ€™s path until they collide. <br />  |    The game triggers a car_Frog_Collision() signal when the frog collides with the car which came from the right.   |     âœ…      |     High     |
| Car Downwards Collision with Frog | Detects a collision between a car and the frog while the latter go upwards but right into a moving car.| 7 |    1. Start the game.<br /> 2. Generate the frog.<br /> 3. Wait for a few clock cycles to allow the frog to appear.<br /> 4. Set the generateCar() signal.<br /> 5. Wait for car generation.<br /> 6. Move the frog and make sure you reach a location where a moving car move in the lane above yours. <br /> 7. Make the frog go upwards at the exact moment where the car is located above it. <br />  |    The game triggers a car_Frog_Collision() signal when the frog collides with the car from below.   |     âœ…     |     Medium     |
| Car Upwards Collision with Frog | Detects a collision between a car and the frog while the latter go downwards but right into a moving car.| 7 |    1. Start the game.<br /> 2. Generate the frog.<br /> 3. Wait for a few clock cycles to allow the frog to appear.<br /> 4. Set the generateCar() signal.<br /> 5. Wait for car generation.<br /> 6. Move the frog and make sure you reach a location where a moving car move in the lane below yours. <br /> 7. Make the frog go downwards at the exact moment where the car is located below it. <br />  |    The game triggers a car_Frog_Collision() signal when the frog collides with the car from above.   |    âœ…     |     Medium     |


#### Win Rules

| Test Name | Description | Number of steps |    Steps list     |    Expected    |       Got       |       Priority       | 
| --------- | ----------------- | -------------------- |    ---------------     |    --------    |       ---       |       ---       | 
| Frog reaches Level End | Send a levelComplete() signal once the frog finished crossing the road.| 4 |    1. Start the game <br /> 2. Generate the frog.  <br /> 3. Wait for a few clock cycles to allow frog generation. <br /> 4. Move the Frog until you reaches the end of the level.<br /> |    A levelComplete() signal is sent when the frog reaches the end.   |     âœ…      |     High     |
| Go to Next Level | Teleports the frog back to its starting point after reaching the end of the level.| 6 |    1. Start the game.<br /> 2. Generate the frog.<br /> 3. Wait for a few clock cycles to allow frog generation.<br /> 4. Move the frog to the end of the level.<br /> 5. Trigger the levelComplete() signal.<br /> 6. Wait for a few clock cycles for the frog to teleport back to the start. <br /> |    The frog sprite disappears from the end of the level and reappears at the starting position within a set number of clock cycles.   |     âœ…     |     High     |
| Game Cleared | Display a message saying "Good Job" when the player complete all levels, until a button is pressed and the game restart at the level 1.| 7 |    1. Start the game. <br /> 2. Generate the frog. <br /> 3. Wait for a few clock cycles to allow frog generation. <br /> 4. Move the frog to the end of the level. <br /> 5. Trigger the levelComplete() signal. <br /> 6. Repeat the steps 2-5 until the last level is finished. <br /> 7. Send the gameCleared() signal. <br /> 8. Make sure the "GOOD JOB" message is displayed. <br /> 9. Press any button input on the FPGA module.|    The "GOOD JOB" message is displayed until the player presses a button and the game is back at level 1.   |     TO BE TESTED.       |     Low     |
| Level Counter | Update the level counter by one when a level is completed.| 5 |    1. Start the game.<br /> 2. Generate the frog.<br /> 3. Wait for a few clock cycles to allow frog generation.<br /> 4. Move the frog to the end of the level.<br /> 5. Trigger the levelComplete() signal.<br />|    The Level Counter is increased by 1 on the FPGA module.   |     âœ…     |     High     |
| Score Counter | Update the Score by adding a fixed value when a level is completed.| 5 |    1. Start the game.<br /> 2. Generate the frog.<br /> 3. Wait for a few clock cycles to allow frog generation.<br /> 4. Move the frog to the end of the level.<br /> 5. Trigger the levelComplete() signal.<br />|    The Score is increased by a fixed value (e.g. 100), and the increase is reflected within a few clock cycles.   |     NOT VALIDATED     |     Medium     |
| Cars Speed Increase | Increase the speed of all cars after 3 levels passed.| 8 |    1. Start the game.<br /> 2. Generate the frog.<br /> 3. Wait for a few clock cycles to allow frog generation.<br /> 4. Move the frog to the end of the level.<br /> 5. Trigger the levelComplete() signal.<br /> 6. Increase the level counter by one.<br /> 7. Repeat the steps 4-6 until you reach the level 4. <br /> 8. Monitor and record the car speeds before and after the level increase. <br /> | All cars' speed increases by a fixed factor (e.g., multiplied by 1.1), and the increase is reflected within a specific number of clock cycles. |     âœ…    |     Low     |
| Cars Continuous Movement | Ensure that when the frog respawns (after going to the next level or dying), the cars on the road continue moving smoothly.| 9 |    1. Start the game.<br /> 2. Generate the frog.<br /> 3. Wait for a few clock cycles to allow frog generation.<br /> 4. Generate multiple moving cars.<br /> 5. Wait for car generation and verify all cars are moving.<br /> 6. Move the frog to the end of the level.<br /> 7. Trigger the levelComplete() signal.<br /> 8. Increase the level counter by one.<br /> 9. Monitor the movement of cars while the frog respawns, ensuring no interruption in their motion. <br /> |    All cars continue moving without interruption throughout the level increase cycle. The frog respawns correctly, and car positions are consistent but they regain their original speed if it was previously increased.   |     âœ…       |     Low     |

#### Lose Rules

| Test Name | Description | Number of steps |    Steps list     |    Expected    |       Got       |       Priority       | 
| --------- | ----------------- | -------------------- |    ---------------     |    --------    |       ---       |       ---       | 
| Frog death | Teleports the frog at the start of the current level.| 7|    1. Start the game.<br /> 2. Generate the frog.<br /> 3. Wait for a few clock cycles to allow the frogâ€™s generation.<br /> 4. Set the generateCar() signal.<br /> 5. Wait for car generation.<br /> 6. Trigger car_Frog_Collision() signal.<br /> 7. Ensure the frog is immediately teleported to the beginning of the level after death. <br /> |    After collision, the frog has been teleported at the beginning to the level.   |    âœ…     |     Medium     |
| All Lives Lost |Ensure that the player has 3 lives and is sent back to the beginning of the current level after losing a life. If all lives are lost, the player returns to the beginning of level 1 and regains all 3 lives.| 6|    1. Start the game.<br /> 2. Allow the frog to collide with a car and lose one life.<br /> 3. Ensure the frog is teleported to the beginning of the current level after losing one life.<br /> 4. Repeat the process until all 3 lives are lost.<br /> 5. Ensure the frog is teleported to the start of level 1 and regains 3 lives after all lives are lost.<br /> 6. Verify that the life counter updates correctly with each life lost and reset. |    After collision, the frog has been teleported at the beginning to the level.   |    âœ…     |     Medium     |
| Frozen Frog| Ensure that the player has 3 lives, and after losing all lives, the frog is frozen at the beginning of level 1, while the cars continue moving. The game resumes fully when the player presses all 4 buttons simultaneously. | 7 |    1. Start the game.<br /> 2. Allow the frog to collide with a car and lose one life.<br /> 3. Ensure the frog is teleported to the beginning of the current level after losing one life.<br /> 4. Repeat the process until all 3 lives are lost.<br /> 5. After the last life is lost, ensure the frog is teleported to the start of level 1, the life counter is reset to 3, and the frog is frozen.<br /> 6. Confirm that the cars continue moving smoothly without any position reset.<br /> 7. Press all 4 buttons simultaneously to unfreeze the frog and resume the game.|   After losing a life, the frog returns to the beginning of the current level. When all lives are lost, the frog is frozen at the start of level 1, the life counter resets to 3, and the cars continue moving smoothly. The game fully resumes when all 4 buttons are pressed simultaneously.  |     âœ…    |     Medium     |

#### Other Rules

| Test Name | Description | Number of steps |    Steps list     |    Expected    |       Got       |       Priority       | 
| --------- | ----------------- | -------------------- |    ---------------     |    --------    |       ---       |       ---       | 
| Score to 0 | Makes sure the score is set at 0 when a new game starts.| 2 |    1. Start the game.<br /> 2. Send a resetScore() signal.<br />|    The Score is set to 0 when we start playing.   |     NOT VALIDATED      |     Medium     |
| One Car per Lane | Ensure only one car can occupy a lane at any time.| 6 |    1. Start the game <br /> 2. Set a generateCar() signal.  <br /> 3. Wait for a few clock cycles to allow car generation. <br /> 4. Attempt to generate another car in the same lane.<br /> 5. Wait for a few clock cycles.<br /> 6. Verify the game prevents the second car from appearing in the same lane. <br /> |    Only one car appears in the lane, and the game prevents the second car from being generated in that lane.   |     âœ…       |     Medium     |
| All Lanes Occupied | Generate one moving car in each lane.| 4 |    1. Start the game <br /> 2. Set a generateCar() signal for the first lane.  <br /> 3. Wait for a few clock cycles to allow car generation and ensure a car has been generated in the first lane. <br /> 4. Repeat steps 2-3 for the other lanes. You can attempt to make the cars move in other directions. <br /> |  One car per lane has been generated, and each is able to drive smoothly and in any direction.   |     âœ…       |     Medium     |
| New lane | Add a new lane on the road with a new moving car when a player passes a level.| 5 |    1. Start the game.<br /> 2. Pass the first level.<br /> 3. Observe if a new lane appears on the screen.<br /> 4. Ensure the new lane includes a moving car.<br /> 5. Verify that the new lane and car behave as expected.|    A new lane with a moving car appears correctly when a level is passed.  |     TO BE TESTED.       |     Low|

### 3-2 Performance Testing

#### Frogger Performance

| Test Name | Description | Number of steps |    Steps list     |    Expected    |       Got       |       Priority       | 
| --------- | ----------------- | -------------------- |    ---------------     |    --------    |       ---       |       ---       | 
| Frog Generation Latency | Ensure the time latency between the game's launch and the frog's generation on its starting point is short (e.g. < 200 ms).| 3 |    1. Start the game <br /> 2. Set a generateFrogger() signal.  <br /> 3. Measure the number of clock cycles required to allow frog generation. <br />  |    The time required to generate the Frog on the map is short.   |     âœ…      |     High     |
| Right Movement Latency | Ensure the frog's movement is responsive when the player presses the Right button.| 5 |    1. Start the game <br />  2. Set a generateFrogger() signal.  <br /> 3. Wait for a few clock cycles to allow the frog's generation. <br /> 4. Set the Right Key input signal.<br /> 5. Measure the number of clock cycles required to allow the frog's movement.  |    The time required to make the frog go right is short (e.g. < 200 ms)    |     âœ…      |     High     |
| Left Movement Latency | Ensure the frog's movement is responsive when the player presses the Left button.| 5 |    1. Start the game <br />  2. Set a generateFrogger() signal.  <br /> 3. Wait for a few clock cycles to allow the frog's generation. <br /> 4. Set the Left Key input signal.<br /> 5. Measure the number of clock cycles required to allow the frog's movement.  |    The time required to make the frog go left is short (e.g. < 200 ms)    |     âœ…     |     High     |
| Up Movement Latency | Ensure the frog's movement is responsive when the player presses the Up button.| 5 |    1. Start the game <br />  2. Set a generateFrogger() signal.  <br /> 3. Wait for a few clock cycles to allow the frog's generation. <br /> 4. Set the Up Key input signal.<br /> 5. Measure the number of clock cycles required to allow the frog's movement.  |    The time required to make the frog go upwards is short (e.g. < 200 ms)    |     âœ…      |     High     |
| Down Movement Latency | Ensure the frog's movement is responsive when the player presses the Down button.| 5 |    1. Start the game <br />  2. Set a generateFrogger() signal.  <br /> 3. Wait for a few clock cycles to allow the frog's generation. <br /> 4. Set the Down Key input signal.<br /> 5. Measure the number of clock cycles required to allow the frog's movement.  |    The time required to make the frog go downwards is short (e.g. < 200 ms)    |     âœ…       |     High     |
| Sprite Rotation Latency | Ensure the frog's rotation is responsive when the player presses a input direction the frog isn't facing.| 5 |    1. Start the game <br />  2. Set a generateFrogger() signal.  <br /> 3. Wait for a few clock cycles to allow the frog's generation. <br /> 4. Set a movement input signal different from the frog's actual direction.  <br /> 5. Measure the number of clock cycles required to allow the frog's rotation<.>.  |    The time required to make the frog rotate is short (e.g. < 200 ms)    |     âœ…      |     Medium     |
| Walking Animation Latency | Ensure the frog's walking animation is responsive.| 5 |    1. Start the game <br />  2. Set a generateFrogger() signal.  <br /> 3. Wait for a few clock cycles to allow the frog's generation. <br /> 4. Set any movement input signal.  <br /> 5. Measure the number of clock cycles to allow the frog's walking animation.  |    The time required to play the frog's walking animation is short (e.g. < 200 ms).    |     TO BE TESTED.       |     Low     |

#### Cars Performance

| Test Name | Description | Number of steps |    Steps list     |    Expected    |       Got       |       Priority       | 
| --------- | ----------------- | -------------------- |    ---------------     |    --------    |       ---       |       ---       | 
| Car Generation Latency | Ensure the time latency between the game's launch and the car's generation on its starting point is short (e.g. < 200 ms).| 3 |    1. Start the game <br /> 2. Set a generateCar() signal.  <br /> 3. Measure the number of clock cycles to allow car generation. |    The time required to generate the car on the map is short.   |     âœ…      |     High     |
| Left Movement Latency | Ensure the car is moving smoothly at the left with a regular latency. | 6 |    1. Start the game <br /> 2. Set a generateCar() signal.  <br /> 3. Wait for a few clock cycles to allow car generation. <br /> 4. Set the moveCarLeft() signal. <br /> 5.Measure the clock cycles between the trigger and the car's first visible movement. <br /> 6. Record the clock cycles for each subsequent movement to ensure consistent latency between steps.|    The car moves to the left at a consistent frame rate, with each movement step occurring after an equal number of clock cycles (based on its speed). No jitter or stuttering is observed.  |     âœ…      |     High     |
| Right Movement Latency | Ensure the car is moving smoothly at the right with consistant latency. | 6 |    1. Start the game <br /> 2. Set a generateCar() signal.  <br /> 3. Wait for a few clock cycles to allow car generation. <br /> 4. Set the moveCarRight() signal. <br /> 5. Measure the clock cycles between the trigger and the car's first visible movement. <br /> 6. Record the clock cycles for each subsequent movement to ensure consistent latency between steps.|    The car moves to the right at a consistent frame rate, with each movement step occurring after an equal number of clock cycles (based on its speed). No jitter or stuttering is observed.  |     âœ…       |     High     |
| Driving Left Animation Latency | Ensure the car's driving animation while moving on the left is responsive.| 6 |    1. Start the game <br /> 2. Set a generateCar() signal.  <br /> 3. Wait for a few clock cycles to allow car generation. <br /> 4. Set the moveCarLeft() signal. <br /> 5. Wait for a few clock cycles to allow car movement. <br /> 6. Measure the number of clock cycles to allow the car's driving animation. |    The time required to play the car's driving animation while moving on the left is short (e.g. < 200 ms).    |     TO BE TESTED.       |     Low     |
| Driving Right Animation Latency | Ensure the car's driving animation while moving on the right is responsive.| 6 |    1. Start the game <br /> 2. Set a generateCar() signal.  <br /> 3. Wait for a few clock cycles to allow car generation. <br /> 4. Set the moveCarRight() signal. <br /> 5. Wait for a few clock cycles to allow car movement. <br /> 6. Measure the number of clock cycles to allow the car's driving animation. |    The time required to play the car's driving animation while moving on the right is short (e.g. < 200 ms).    |     TO BE TESTED.       |     Low     |
| Car Right Generation Latency | Ensure the car is smoothly appearing from the right side of the road and moves to the left with consistant latency.| 6 |    1. Start the game <br /> 2. Set a generateCarFromRight() signal.  <br /> 3. Wait for a few clock cycles to allow car generation. <br /> 4. Set the moveCarLeft() signal. <br /> 5. Measure the number of clock cycles between the trigger and the car's first visible movement. <br /> 6. Record the clock cycles for each subsequent movement to ensure consistent latency between steps. |    The car appears on the right and moves to the left at a consistent frame rate, with each movement step occurring after an equal number of clock cycles (based on its speed). No jitter or stuttering is observed.    |     âœ…      |     Medium     |
| Car Left Generation Latency | Ensure the car is smoothly appearing from the left side of the road and moves to the right with consistant latency.| 6 |    1. Start the game <br /> 2. Set a generateCarFromLeft() signal.  <br /> 3. Wait for a few clock cycles to allow car generation. <br /> 4. Set the moveCarRight() signal. <br /> 5. Measure the number of clock cycles between the trigger and the car's first visible movement. <br /> 6. Record the clock cycles for each subsequent movement to ensure consistent latency between steps. |    The car appears on the left and moves to the right at a consistent frame rate, with each movement step occurring after an equal number of clock cycles (based on its speed). No jitter or stuttering is observed.    |     âœ…     |     Medium     |
| Car Left Disappearance Latency | Ensure a car coming from the right is smoothly disappearing when it reaches the left side of the screen with constant latency.| 9 |    1. Start the game.<br /> 2. Set the generateCarFromRight() signal.<br /> 3. Wait for a few clock cycles to allow car generation.<br /> 4. Set the moveCarLeft() signal.<br /> 5. Wait for a few clock cycles to allow car movement.<br /> 6. Wait until the car reaches the left screen edge.<br /> 7. Set the disappearCarOnLeft() signal.<br /> 8. Measure the number of clock cycles between the trigger and the car's visible disappearance. <br /> 9. Record the clock cycles for each subsequent movement to ensure consistent latency between steps.|    The car that came from the right is fading on the left at a consistent frame rate, with each movement step occurring after an equal number of clock cycles (based on its speed). No jitter or stuttering is observed.   |     âœ…     |     Medium     |
| Car Right Disappearance Latency | Ensure a car coming from the left is smoothly disappearing when it reaches the right side of the screen with constant latency.| 9 |    1. Start the game.<br /> 2. Set the generateCarFromLeft() signal.<br /> 3. Wait for a few clock cycles to allow car generation.<br /> 4. Set the moveCarRight() signal.<br /> 5. Wait for a few clock cycles to allow car movement.<br /> 6. Wait until the car reaches the right screen edge.<br /> 7. Set the disappearCarOnRight() signal.<br /> 8. Measure the number of clock cycles between the trigger and the car's visible disappearance. <br /> 9. Record the clock cycles for each subsequent movement to ensure consistent latency between steps.|    The car that came from the left is fading on the right at a consistent frame rate, with each movement step occurring after an equal number of clock cycles (based on its speed). No jitter or stuttering is observed.   |     âœ…      |     Medium     |
| Speed Increase Latency | Ensure a car's speed is responsive when we trigger the speed increase.| 9 |    1. Start the game. <br /> 2. Generate the frog. <br/> 3. Wait for a few clock cycles to allow frog generation. <br /> 3. Set a generateMovingCar() signal.  <br /> 4. Wait for a few clock cycles to allow car generation. <br /> 5. Reach the end of the level with the frog. <br /> 6. Repeat step 5 until you reach the level 4. <br /> 7. Trigger increaseCarSpeed() to request a speed increase. <br /> 8. Measure the number of clock cycles between the speed increase trigger and when the car's movement reflects the speed change. <br /> 9. Record the clock cycles for each subsequent movement step to verify consistent and reduced latency after the speed increase. |    The speed increase is applied within a short time (e.g., less than 200ms) at level 4. After the speed change, the car moves to the left with reduced but consistent frame intervals (i.e., the number of clock cycles per movement step decreases, but steps remain evenly spaced). No jitter or stutter is observed.   |     âœ…      |     Medium     |
| Speed Increase Influence | Check if increasing the speed of a car causes any frame drops or slowdowns.| 8 |    1. Start the game. <br /> 2. Set a generateCar() signal.  <br /> 3. Wait a few clock cycles for car generation. 4.  Trigger moveCarLeft() to initiate car movement. <br /> 5. Allow a few clock cycles to establish normal movement. <br /> 6. Trigger the increaseCarSpeed() signal. <br /> 7. Monitor the car's speed increase and the game's frame rate after the speed change. <br /> 8. Track whether the game's frame rate or the carâ€™s movement speed experiences any drops, slowdowns, or irregularities post-speed increase. |    No frame drops or slowdowns are observed after the speed increase. The car continues to move smoothly, with faster but consistently spaced movement steps.   |      âœ…       |     Medium     |
| Car Full Number Influence | Check if having one moving car per lane causes any frame drops or slowdowns.| 10 |     1. Start the game <br /> 2. Set a generateCar() signal for the first lane.  <br /> 3. Wait for a few clock cycles to allow car generation and ensure a car has been generated in the first lane. Monitor the game's frame rate after the car's generation. <br /> 4. Repeat steps 2-3 for the other lanes. You can attempt to make the cars move in other directions. <br /> 5. Track if the game's frame rate after all cars have been generated experiences any drops, slowdowns, or irregularities. |   No frame drops or slowdowns are observed and each car continues to move smoothly.    |      âœ…     |     Medium     |

#### Collision Performance

| Test Name | Description | Number of steps |    Steps list     |    Expected    |       Got       |       Priority       | 
| --------- | ----------------- | -------------------- |    ---------------     |    --------    |       ---       |       ---       | 
| Car Collision with Frog Latency | Ensure the time latency between the actual car-frog collision  and the collision signal trigger is short (e.g. < 200 ms).| 8 |    1. Start the game.<br /> 2. Generate the frog.<br /> 3. Wait for a few clock cycles to allow the frog to appear.<br /> 4. Set the generateCar() signal.<br /> 5. Wait for car generation.<br /> 6. Move the frog into the carâ€™s path until they collide  (test left, right, upwards, and downwards collisions). <br /> 7. Measure the clock cycles between the actual in-game collision and the triggering of the car_Frog_Collision() signal. <br /> 8. Verify if the frog respawns immediately at its starting point after the collision (visual confirmation).|  The time between the in-game car-frog collision and the car_Frog_Collision() signal trigger is short, ideally less than 200ms (or a specific number of clock cycles). The frog stops respawns at its starting point immediately after the collision, with no delay.   |      âœ…       |     High     |
| Car Collision with Frog Latency (Multiple Levels)  | Ensure that across multiple levels, even with increasing car speeds, the system detects the collision precisely when the frog and car intersect. After each collision, the frog respawns at the starting point of the current level until all lives are lost.| 8 |   1. Start the game.<br /> 2. Generate the frog.<br /> 3. Wait for a few clock cycles to allow the frog to appear.<br /> 4. Set the generateAllCars() signal. <br /> 5. Progresses throughout the levels until you go beyond the level 9. <br /> 6. Trigger a collision between the frog and a high speed car. <br /> 7. Measure the number of clock cycles between the actual in-game collision and the triggering of the car_Frog_Collision() signal. <br /> 8. Verify if the frog respawns immediately at its starting point after the collision (visual confirmation). |   Collision detection remains accurate even at higher speeds. The car_Frog_Collision() signal triggers within 200ms (or a specific number of clock cycles). The frog respawns at its starting point immediately on collision with no delay, and no collisions are missed.    |      âœ…      |     Medium     |
| Frog Common Death Influence | Ensure that the frog dies several times in the game, there are no frame drops or slowdowns for the frog, the cars, or the game itself. | 12 |    1. Start the game.<br /> 2. Generate the frog.<br /> 3. Wait for a few clock cycles to allow the frog to appear.<br /> 4. Set the generateAllCars() signal.<br /> 5. Wait for all cars' generation.<br /> 6. Move the frog into a carâ€™s path until they collide.<br /> 7. Measure the clock cycles between the actual in-game collision and the triggering of the car_Frog_Collision() signal.<br /> 8. Verify if the frog respawns immediately at its starting point on level 1 after the collision (visual confirmation).<br /> 9. Check that the cars continue moving smoothly without resetting or freezing.<br /> 10. If you have lost all of your lives while dying several times and you are frozen, press all 4 direction inputs (Left, Right, Up, Down) simultaneously and ensure the game restarts without lag or interruptions.<br /> 11. After each death, monitor the framerate of the game, frog, and cars for any frame drops or slowdowns.<br /> 12. Repeat steps 6-11 multiple times and track whether any frame drops or slowdowns occur in the frogâ€™s movement, the carsâ€™ movement, or the overall game.|    After each frog death, there are no significant frame drops or slowdowns in the game, frog, or cars. The game restarts without lag, and all entities continue running smoothly at their expected speeds.   |     âœ…       |     Medium     |

#### Win Rules Performance

| Test Name | Description | Number of steps |    Steps list     |    Expected    |       Got       |       Priority       | 
| --------- | ----------------- | -------------------- |    ---------------     |    --------    |       ---       |       ---       | 
| Frog Next Level Latency | Ensure the time latency between the frog's arrival to the end of the level and its respawn at the starting point for the next level is short (e.g., < 200 ms).| 8 |    1. Start the game. <br /> 2. Set a generateFrogger() signal.  <br /> 3. Move the frog until it reaches the end of the level. <br /> 4. Trigger the levelComplete() signal. <br /> 5. Measure the number of clock cycles or time between the frogRespawn() signal and the frog's actual appearance at its starting point. <br /> 6. Track the framerate of the game during this process to ensure no slowdowns occur during respawn. <br /> 7. Ensure the frog appears smoothly at the starting point without glitches or delays. | The time required to respawn the frog after a level is completed should be less than 200 ms (or a pre-defined acceptable threshold), with no frame drops or slowdowns during the respawn process. The frog should reappear smoothly at the starting point, and the game should continue running at a consistent frame rate.   |     âœ…      |    Medium    |
| Frog Level Progress Influence| Check if after each level passed, there is any frame drops or slowdowns among the frog, the cars or the game itself, especially when car speeds increase.| 8 |    1. Start the game. <br /> 2. Set a generateFrogger() signal.  <br /> 3. Move the frog until it reaches the end of the level. <br /> 4. Trigger the levelComplete() signal. <br /> 5. Measure the number of clock cycles or time between the frogRespawn() signal and the frog's actual appearance at its starting point. <br /> 6. Track the framerate of the game, including the frog and cars, during this process to ensure no slowdowns occur during respawn or car speed increases. <br /> 7. Ensure the frog and cars continue moving at their expected speeds and framerates with no frame drops or glitches. <br /> 8. Repeat the steps 3-8 until you finish last level (e.g. level 8). |    After each level is passed and car speeds increase, no significant frame drops or slowdowns occur. The game, frog, and cars run smoothly at their expected speeds and framerates with no performance degradation.   |     âœ…     |     Medium     |
| Game Cleared Latency| Ensure the time latency between the levelComplete() signal trigger and the displaying of the "Good Job" message is short (e.g. < 200 ms).| 8 |    1. Start the game. <br /> 2. Generate the frog. <br /> 3. Wait for a few clock cycles to allow frog generation. <br /> 4. Move the frog to the end of the level. <br /> 5. Trigger the levelComplete() signal. <br /> 6. Repeat the steps 2-5 until the last level is finished. <br /> 7. Send the gameCleared() signal. <br /> 8. Monitor the number of clock between the signal trigger and when the message starts being displayed.|    The message is displayed with minimum latency.   |     TO BE TESTED.       |     Low     |
| Game Cleared Message Remove Latency | Ensure the latency between pressing a button at the appearance of the message saying "Good Job" when the player complete all levels and the game restart at the level 1 is short (e.g. <200 ms).| 10 |    1. Start the game. <br /> 2. Generate the frog. <br /> 3. Wait for a few clock cycles to allow frog generation. <br /> 4. Move the frog to the end of the level. <br /> 5. Trigger the levelComplete() signal. <br /> 6. Repeat the steps 2-5 until the last level is finished. <br /> 7. Send the gameCleared() signal. <br /> 8. Make sure the "GOOD JOB" message is displayed. <br /> 9. Press any button input on the FPGA module. <br /> 10. Monitor the number of clock between the button input and the return to the level 1.|    The "GOOD JOB" message is displayed until the player presses a button and the game is back at the level 1 with a short latency.   |     TO BE TESTED.       |     Low     |
| Score Counter Latency | Ensure the score is updated with a short latency (e.g. < 200 ms) when a level is completed.| 6 |    1. Start the game.<br /> 2. Generate the frog.<br /> 3. Wait for a few clock cycles to allow frog generation.<br /> 4. Move the frog to the end of the level.<br /> 5. Trigger the levelComplete() signal.<br /> 6. Monitor the number of clock between the signal trigger and when the score is updated on screen.|    The score increase latency is short.   |     NOT VALIDATED      |     Medium     |
| Level Counter Latency | Ensure the level counter is updated with a short latency (e.g. < 200 ms) when a level is completed.| 5 |    1. Start the game.<br /> 2. Generate the frog.<br /> 3. Wait for a few clock cycles to allow frog generation.<br /> 4. Move the frog to the end of the level.<br /> 5. Trigger the levelComplete() signal.<br /> 6. Monitor the number of clock between the signal trigger and when the level counter is updated on the FPGA module. |    The Level Counter increase latency is short.   |     âœ…      |     High     |
| Cars Continuous Movement Influence | Measure the latency and framerate consistency of cars during the frog respawn phase (after moving to the next level), ensuring cars move without interruption.| 10 |    1. Start the game.<br /> 2. Generate the frog.<br /> 3. Wait for a few clock cycles to allow frog generation.<br /> 4. Trigger multiple generateCar() signals to produce moving cars.<br /> 5. Wait for car generation and verify that all cars are moving smoothly.<br /> 6. Move the frog to the end of the level.<br /> 7. Trigger the levelComplete() signal.<br /> 8. Increase the level counter by one.<br /> 9. Monitor the carsâ€™ motion during the frog respawn process. <br /> 10. Measure the framerate and latency of car movement during this phase, ensuring no slowdowns or interruptions.|    Car motion remains smooth, and no frame drops or slowdowns are detected. The latency between the frog respawn and car motion continuity is minimal (e.g., < 100 ms). Car positions remain consistent during and after the frog respawn.   |     âœ…       |     Low     |
| New lane Influence | Check if adding a new lane on the road causes any frame drops or slowdowns.| 5 |    1. Start the game.<br /> 2. Pass the first level.<br /> 3. Observe if a new lane is added.<br /> 4. Monitor the game's performance (e.g. FPS).<br /> 5. Ensure no frame drops or slowdowns occur.|    The game should not experience any performance degradation when a new lane is added.  |     TO BE TESTED.       |     Low|

#### Lose Rules Performance

| Test Name | Description | Number of steps |    Steps list     |    Expected    |       Got       |       Priority       | 
| --------- | ----------------- | -------------------- |    ---------------     |    --------    |       ---       |       ---       | 
| Frog Frozen after Death Performance | Ensure that the latency between the frog's teleportation to the beginning of the level 1 after 3 lives lost and the frog freezing is short (e.g., < 200 ms), with all cars' positions remaining the same without frame drops or slowdowns. | 11 |    1. Start the game.<br /> 2. Generate the frog.<br /> 3. Wait for a few clock cycles to allow the frogâ€™s generation.<br /> 4. Set the generateAllCars() signal.<br /> 5. Wait for all cars' generation.<br /> 6. Trigger car_Frog_Collision() signal.<br /> 7. Repeat step 6 until you lost all of your 3 lives. <br />  8. Measure the clock cycles or time between the frog's collision and its teleportation to the start of the level 1. <br /> 9. Ensure the level counter is immediately set to 1 after the frogâ€™s teleportation. <br /> 10. Check that the positions of all cars remain the within their respective lanes without any delay, and monitor their speed are set to their original values. <br /> 11. Verify the frog is frozen immediately after its respawn. <br /> 12. Ensure there are no frame drops or slowdowns during the freeze process, that the car continue to move smoothlu, and the frog remain frozen without any unexpected movement.|    The frog freeze occurs within a short latency (e.g., < 200 ms) after the frog's triple deaths and teleportation. All cars are still moving without interruption, at their original speed, and the frog freeze is smooth with no frame drops or slowdowns. The frog remains frozen.  |     âœ…        |     Medium     |
| Frog Unfreeze Performance | Ensure the latency between pressing all 4 buttons and the frog leaving its frozen state is short (e.g., < 200 ms), with the frog and cars resuming their movement smoothly without frame drops or slowdowns. | 11 |    1. Start the game.<br /> 2. Generate the frog.<br /> 3. Wait for a few clock cycles to allow the frogâ€™s generation.<br /> 4. Set the generateAllCars() signal.<br /> 5. Wait for all cars' generation.<br /> 6. Trigger car_Frog_Collision() signal.<br /> 7. Repeat the step 6 until you lose all of your 3 lives. <br /> 8. Ensure the frog is teleported to the beginning of the level 1, and is frozen. <br /> 9. Press all 4 buttons simultaneously. <br /> 10. Measure the time or clock cycles between pressing the buttons and the frog resuming its movement. <br /> 11. Ensure the frog resume its motion smoothly, without any frame drops or slowdowns.|    The frog resumes his movement smoothly with a short latency (e.g., < 200 ms) after pressing all 4 buttons, and start walking again without any delays or performance degradation.  |     âœ…       |     Medium     |
| Frog Multiple Deaths Influence | Check if after each death occured, there is any frame drops or slowdowns among the frog, the cars or the game itself.| 9 |    1. Start the game.<br /> 2. Generate the frog.<br /> 3. Wait for a few clock cycles to allow frog generation.<br /> 4. Set the generateCar() signal.<br /> 5. Wait for car generation.<br /> 6. Trigger the car_Frog_Collision() signal.<br /> 7. Measure the number of clock cycles or time between the frogRespawn() signal and the frog's actual appearance at its starting point. <br /> 8. Track the framerate of the game during this process to ensure no slowdowns occur during respawn. <br /> 9. Repeat steps 4-8 several times.<br /> |    After each death and and each time the frog respawned, no significant frame drops or slowdowns occur. The game, frog, and cars continue running at their expected speeds and framerates with no visual or performance degradation.   |     âœ…        |     Medium     |

#### Other Rules Performance

| Test Name | Description | Number of steps |    Steps list     |    Expected    |       Got       |       Priority       | 
| --------- | ----------------- | -------------------- |    ---------------     |    --------    |       ---       |       ---       | 
| Score to 0 Latency| Ensure the latency between the beginning of the game and the score being set at 0 is short (e.g. < 200 ms).| 2 |    1. Start the game.<br /> 2. Send a resetScore() signal.<br /> 3. Monitor the number of clock between the signal trigger and when the score is shown being reset to 0.|    The Score is set to 0 with a short latency.   |     NOT VALIDATED     |     Medium     |


### 3-3 Stress Testing

| Test Name | Description | Number of steps |    Steps list     |    Expected    |       Got       |       Priority       | 
| --------- | ----------------- | -------------------- |    ---------------     |    --------    |       ---       |       ---       | 
| Several Buttons at the Same Time| Check the game's behavior and performance while the player press several buttons at the same time.| 5 |    1. Start the game.<br /> 2. Press all movement buttons (up, down, left, right) at the same time.<br /> 3. Monitor if the game freezes, slows down, or crashes.<br /> 4. Check if the frog responds to any movement or stays frozen.<br /> 5. Check if game mechanics (cars, score, time) continue functioning normally.|    The game continues without freezing or crashing. Frog moves strictly to the 1st movement input the game has detected, and the rest of the mechanics work as expected.  |     âœ…       |     Medium     |
| Typing while Freeze| Check the game's behavior and performance when the player presses 1 to 3 buttons simultaneously while the game is frozen after the frog death, and before the game restart. | 6 |    1. Start the game.<br /> 2. Let the frog collide with a car. <br /> 3. Repeat the step 2 until you lose your 3 lives. <br /> 4. Make sure the game is back at level 1 and the frog is frozen in its starting position.<br /> 5. While the frog is frozen, press 1 to 3 movement buttons at the same time.<br /> 6. Observe if any input is registered, and check for game response when it resumes.|    No inputs should affect the game while frozen. When the game resumes, it should continue as expected with no movement from earlier inputs.  |     âœ…        |     Medium     |
| Frog Hits Car's Back| Check the game's behavior and performance when the frog move towards the back of a moving car and they collide while both are moving in the same direction. Both direction should be checked.| 6 |    1. Start the game.<br /> 2. Position the frog behind a car moving in the same direction.<br /> 3. Move the frog forward to collide with the back of the car.<br /> 4. Observe if the collision is detected, and note the response (e.g., death or pass through).<br /> 5. Repeat in the opposite direction.<br /> 6. Record performance during the collision event.|    Collision should be detected correctly, causing the frog's death, and game performance should remain smooth.  |     âœ…        |     Medium     |
| Car Chases Frog| Check the game's behavior and performance when the frog move while being chased by a moving frog from behind and they collide while both are moving in the same direction. Both direction should be checked.| 6 |    1. Start the game.<br /> 2. Position a car behind the frog, both moving in the same direction.<br /> 3. Move the frog forward while the car follows.<br /> 4. Observe the collision when the car reaches the frog from behind.<br /> 5. Repeat the test with the opposite direction.<br /> 6. Record any performance issues during or after the collision.|    The collision should be detected as a hit, resulting in the frog's death, with no performance degradation.  |     âœ…       |     Medium     |
| Frog to Bottom Wall| Check the game's behavior and performance while the player make the frog go to the bottom of the screen.| 3 |    1. Start the game.<br /> 2. Move the frog continuously down until it reaches the bottom edge of the screen.<br /> 3. Check for proper boundary handling and performance during and after hitting the bottom wall.|    The frog should not move beyond the bottom boundary, and the game performance should remain stable with no glitches.  |     âœ…     |     Medium     |
| Frog to Left Wall| Check the game's behavior and performance while the player make the frog go to the left limit of the screen.| 3 |    1. Start the game.<br /> 2. Move the frog continuously to the left until it reaches the screen's edge.<br /> 3. Observe if the frog stops at the boundary and if the game performance remains smooth.|    The frog should stop at the left boundary without moving beyond it. The game should continue running smoothly without lag or visual glitches.  |     âœ…       |     Medium     |
| Frog to Right Wall| Check the game's behavior and performance while the player make the frog go to the right limit of the screen.| 3 |    1. Start the game.<br /> 2. Move the frog continuously to the right until it reaches the screen's edge.<br /> 3. Observe if the frog stops at the boundary and if the game performance remains smooth.|    The frog should stop at the right boundary without moving beyond it. The game should continue running smoothly without lag or visual glitches.  |     When the frog reach the right limit, a few additional pixels appear below the frog's bottom legs.        |     Medium     |
| Huge Loading Environment| Try playing the game and check its behavior and performance while several applications and software are loaded in parallel, creating a difficult loading environment.| 4 |    1. Open multiple heavy applications (e.g., browser with many tabs, IDE, etc.) while the game is running.<br /> 2. Start the game and monitor the frame rate and input latency.<br /> 3. Observe the game's performance under the load.<br /> 4. Record if there are any slowdowns, frame drops, or crashes.|    The game should continue running with minimal impact on performance, despite the heavy load. There should be no major frame drops or input delays.   |     NOT VALIDATED      |     Medium     |

### 3-4 Hardware Testing

| Test Name | Description | Number of steps |    Steps list     |    Expected    |       Got       |       Priority       | 
| --------- | ----------------- | -------------------- |    ---------------     |    --------    |       ---       |       ---       | 
| FPGA Module Connection| Check if the FPGA Module connects well to the computer.| 4 |    1. Connect the FPGA module to the computer via USB.<br /> 2. Check for a successful connection signal (e.g., LED indication or device recognition on the computer).<br /> 3. Ensure the FPGA module is recognized by the development environment.<br /> 4. Record if any connection issues occur.|    The FPGA module connects smoothly, with no connection issues.  |      âœ…        |     High     |
| Target Hardware| Make sure the game runs correctly on the specific hardware (Go Board with an ICE40 FPGA).| 4 |    1. Load the game program onto the FPGA module.<br /> 2. Power up the Go Board and start the game.<br /> 3. Ensure the game runs properly, without crashes or freezing.<br /> 4. Monitor performance metrics such as frame rate and button input responsiveness. |    The game runs correctly on the hardware with smooth performance.   |     âœ…        |     High     |
| FPGA Module Upload| Check if the uploading FPGA Module update correctly the expected program to the game's logic.| 4 |    1. Modify the game program or create an updated version.<br /> 2. Upload the new program to the FPGA module.<br /> 3. Check if the game logic reflects the changes (e.g., new behavior, updated mechanics).<br /> 4. Ensure the game runs with the updated logic without issues. |    The updated program is successfully uploaded and reflected in the game.  |    âœ… but only on Mac       |     High     |
| Left Button Switch| Check if the game responds correctly to the Left Button trigger of the FPGA module. Also ensure the latency is low (e.g. < 200ms).| 3 |    1. Press the Left Button on the FPGA module during gameplay.<br /> 2. Observe if the frog moves left in response to the button press.<br /> 3. Measure the latency between the button press and frog movement.|    The frog moves left with minimal latency (<200ms).  |     âœ…     |     High     |
| Right Button Switch| Check if the game responds correctly to the Right Button trigger of the FPGA module. Also ensure the latency is low (e.g. < 200ms).| 3 |    1. Press the Right Button on the FPGA module during gameplay.<br /> 2. Observe if the frog moves right in response to the button press.<br /> 3. Measure the latency between the button press and frog movement.|    The frog moves right with minimal latency (<200ms).  |     âœ…      |     High     |
| Up Button Switch| Check if the game responds correctly to the Up Button trigger of the FPGA module. Also ensure the latency is low (e.g. < 200ms).| 3 |    1. Press the Up Button on the FPGA module during gameplay.<br /> 2. Observe if the frog moves upwards in response to the button press.<br /> 3. Measure the latency between the button press and frog movement.|    The frog moves upwards with minimal latency (<200ms).  |    âœ…       |     High     |
| Down Button Switch| Check if the game responds correctly to the Down Button trigger of the FPGA module. Also ensure the latency is low (e.g. < 200ms).| 3 |    1. Press the Down Button on the FPGA module during gameplay.<br /> 2. Observe if the frog moves downwards in response to the button press.<br /> 3. Measure the latency between the button press and frog movement.|    The frog moves downwards with minimal latency (<200ms).  |     âœ…      |     High     |
| All Buttons Switches| Check if the game responds correctly when the player trigger all 4 buttons of the FPGA module simultaneously. Also ensure the latency is low (e.g. < 200ms).| 6 |    1. Start the game. <br /> 2. Move the frog in collision of a car and dies. <br /> 3. Ensure the frog is teleported to its starting point and that the game is frozen. <br /> 4. Press all 4 buttons simultaneously.<br /> 5. Monitor the game's reaction to the input.<br /> 6. Measure the latency of the response.<br /> |    The game should correctly handle multiple button presses with minimal latency (<200ms). No input should be missed and the 4 buttons must trigger the game restart.  |     âœ…        |     Medium     |
| Holding Button | If a button from the FPGA module is being held down, the frog will not continue to go in that direction. | 5 |    1. Start the game.<br /> 2. Hold down one of the direction buttons (left, right, up, or down).<br /> 3. Observe the frog's movement.<br /> 4. Verify that the frog does not continue moving continuously.<br /> 5. Release the button and observe if the frog stops correctly.|    The frog should only move once per button press, even if the button is held.  |     âœ…        |     Medium   |
| 7-Segment Display| Make sure the 7-segment display of the FPGA module are functionnal.| 4 |     1. Load a simple test program to display numbers on the 7-segment display.<br /> 2. Power up the FPGA and verify each segment lights up as expected.<br /> 3. Check that all segments are functioning by displaying numbers from 0 to 9.<br /> 4. Verify the display accuracy during gameplay.|    The 7-segment display works correctly, showing expected numbers or data.   |     âœ…       |     High     |
| Level Counter Display| Make sure the 7-segment display the correct number from 1 to the max level when the player progresses throughout the levels. Also ensure the latency is low (e.g. < 200ms).| 4 |    1. Progress through the game levels.<br /> 2. Check if the 7-segment display updates the level count after each level is completed.<br /> 3. Measure the latency between level progression and display update.<br /> 4. Verify the display shows the correct level number. |    The 7-segment display shows the correct level number with minimal latency.  |     âœ…       |     High     |
| FPGA Ressources| Check if the FPGAâ€™s resources (like LUTs, memory) are not being over-utilized.| 4 |    1. Monitor FPGA resource usage during synthesis (e.g., logic units, memory).<br /> 2. Run the game and monitor resource utilization during gameplay.<br /> 3. Check if resource usage remains below critical thresholds.<br /> 4. Verify the game runs smoothly without exhausting the FPGA resources.|    FPGA resources are within safe limits, and the game runs without performance issues.  |     The game works without performance problem on Mac (91% of LUTs used), but the game can't be uploaded by a Windows computer (107% of LUTs used).       |     Low     |

### 3-5 User Interface Testing

#### Frog U.I.

| Test Name | Description | Number of steps |    Steps list     |    Expected    |       Got       |       Priority       | 
| --------- | ----------------- | -------------------- |    ---------------     |    --------    |       ---       |       ---       | 
| Frog Sprite Display| Ensure the game displays correctly the frog's sprite on the screen.| 4 |    1. Start the game.<br /> 2. Check if the frog's sprite appears on the screen.<br /> 3. Ensure the sprite is centered in the starting position.<br /> 4. Verify the sprite is fully rendered without missing pixels.|    The frog's sprite is displayed correctly, centered, and fully rendered.  |    When the frog reach the right limit, a few additional pixels appear below the frog's bottom legs.     |     High     |
| Frog Movement Display| Ensure the game displays correctly the frog's movement on the screen when the player trigger a movement input. All 4 directions (Left, Right, Up and Down) must be tested.| 5 |    1. Press the Left button and check the frog's movement.<br /> 2. Press the Right button and check the frog's movement.<br /> 3. Press the Up button and check the frog's movement.<br /> 4. Press the Down button and check the frog's movement.<br /> 5. Ensure smooth display of the frog's movement in all directions.|    The frog moves in all four directions smoothly and displays correctly.   |     âœ…       |     High     |
| Frog Orientation Display| Ensure the game displays correctly the frog's orientation on the screen when the player trigger a movement input different from the frog's current direction. All 4 directions (Left, Right, Up and Down) must be tested.| 4 |    1. Press the Left button when the frog is facing another direction and observe the orientation change.<br /> 2. Press the Right button and observe the orientation change.<br /> 3. Press the Up button and observe the orientation change.<br /> 4. Press the Down button and observe the orientation change.|    The frog correctly changes orientation when moving in different directions.   |     âœ…       |     Medium     |
| Frog Walking Animation Display| Ensure the game displays correctly the frog's walking animation on the screen while its moving.| 4 |    1. Trigger a movement input.<br /> 2. Observe the frog's walking animation while moving.<br /> 3. Ensure the animation is smooth and continuous.<br /> 4. Verify the animation stops when the frog stops moving. |    The frog's walking animation is displayed smoothly during movement and stops when the frog is idle.   |     TO BE TESTED.       |     Low     |

#### Car U.I.

| Test Name | Description | Number of steps |    Steps list     |    Expected    |       Got       |       Priority       | 
| --------- | ----------------- | -------------------- |    ---------------     |    --------    |       ---       |       ---       | 
| Car Sprite Display| Ensure the game displays correctly the car's sprite on the screen. This case must be tested for each of the car's possible directions (Left and Right).| 5 |    1. Start the game.<br /> 2. Observe the car's sprite when it is first displayed on the screen.<br /> 3. Ensure the sprite is fully rendered with no missing or distorted pixels.<br /> 4. Verify that the car's sprite is displayed clearly when moving Left to Right.<br /> 5. Verify that the car's sprite is displayed clearly when moving Right to Left.|    The car's sprite is displayed correctly, fully rendered, and clear, regardless of movement direction.  |     âœ…       |     High     |
| Car Movement Display| Ensure the game displays correctly the car's movement while driving on the screen, from Right to Left and from Left to Right, and that its movement is straight and smooth.| 5 |    1. Start the game.<br /> 2. Observe the car's movement from Left to Right.<br /> 3. Observe the car's movement from Right to Left.<br /> 4. Ensure that the car's movement is straight and not erratic.<br /> 5. Verify that the movement is smooth without any glitches or slowdowns.|    The car moves smoothly and straight in both directions.  |     âœ…       |     High     |
| Car Driving Animation Display| Ensure the game displays correctly the car's driving animation on the screen, from Right to Left and from Left to Right.| 5 |    1. Start the game.<br /> 2. Observe the car's driving animation while moving from Left to Right.<br /> 3. Observe the car's driving animation while moving from Right to Left.<br /> 4. Ensure the animation is smooth and continuous.<br /> 5. Verify that the animation runs correctly throughout the car's journey.|    The car's driving animation is displayed smoothly during movement.   |     TO BE TESTED.       |     Low     |
| Car Appearance Display| Ensure the game displays correctly the car sprite's progressive appearance from the left or right edge of the screen, and that its movement is straight and smooth.| 5 |     1. Start the game.<br /> 2. Observe the car's appearance from the Left edge.<br /> 3. Observe the car's appearance from the Right edge.<br /> 4. Ensure the sprite is fully visible as it enters the screen.<br /> 5. Verify that the car moves straight and smoothly upon appearing.|     The car appears progressively from the screen edges with smooth movement.  |     âœ…       |     High     |
| Car Disappearance Display| Ensure the game displays correctly the car sprite's progressive fading when reaching the left or right edge of the screen, and that its movement is straight and smooth.| 5 |    1. Start the game.<br /> 2. Observe the car's disappearance towards the Left edge.<br /> 3. Observe the car's disappearance towards the Right edge.<br /> 4. Ensure the sprite progressively fades out as it leaves the screen.<br /> 5. Verify that the car moves straight and smoothly upon disappearing.|    The car disappears progressively at the screen edges with smooth movement.  |    âœ…      |     High     |

#### Other U.I.

| Test Name | Description | Number of steps |    Steps list     |    Expected    |       Got       |       Priority       | 
| --------- | ----------------- | -------------------- |    ---------------     |    --------    |       ---       |       ---       | 
| Displaying Colors | Ensure the following colors utilized for the sprites are displayed correctly on screen: Yellow, Green, Black, White, Red, Light Blue, Light Green, and Grey. | 5 |    1. Start the game.<br /> 2. Observe all sprite colors on the screen.<br /> 3. Verify the colors are displayed correctly.<br /> 4. Ensure no color distortion or mismatches occur.<br /> 5. Confirm that each color matches the expected appearance.|    All listed colors should appear correctly and without distortion.  |     âœ…      |     Low|
| Score Display| Ensure the Score is correctly displayed at the top of the screen.| 4 |    1. Start the game.<br /> 2. Observe the score at the top of the screen.<br /> 3. Verify that the initial score is 0.<br /> 4. Ensure that the score is clear, fully displayed, and not distorted.|    The score is displayed at the top, starting from 0, and appears clearly.  |     NOT VALIDATED      |     Medium     |
| Score Update Display| Ensure the Score's update is correctly visible and changed with a low latency (e.g. < 200ms).| 3 |    1. Play the game and increase the score by accomplishing levels.<br /> 2. Observe the score update on the screen.<br /> 3. Verify that the score change occurs within 200ms.|    The score updates correctly, visible immediately after the event with no noticeable delay.  |     NOT VALIDATED       |     Medium     |
| Frog Freeze Display | Ensure the frog is shown at its starting point, the cars are still displayed at the current location, and the frog looks frozen after the player dies.| 5 |    1. Start the game.<br /> 2. Let the frog die (collision).<br /> 3. Repeat the previous step 3 times until you have no lives left. <br /> 4. Observe that the frog respawns at the starting point and at the level 1.<br /> 5. Verify that cars are still displayed in their current locations and the frog is frozen.|    The frog is shown being teleported at its starting point and freezes while the cars are still in their current spots.  |     âœ…          |     Medium     |
| Frog Unfreeze Display | Ensure that once the player restart the game, the game doesn't appear frozen anymore and can be shown moving.| 6 |    1. Start the game.<br /> 2. Let the frog die (collision).<br /> 3. Repeat the previous step 3 times until you have no lives left. <br /> 4. Ensure the frog is back to its starting point and that looks frozen. <br /> 5. Restart the game by pressing all 4 buttons (Right, Left, Up and Down).<br /> 6. Ensure that frog resume movement and does not remain frozen.|    The game resumes, with the frog being able to move smoothly.  |     âœ…       |     Medium    |
| Game Cleared Message Displayed| Ensure that once the player finish the entire game, the "Good job !" message is correctly displayed on the screen with a short latency (e.g. < 200ms).| 3 |    1. Finish the game by completing all levels.<br /> 2. Observe the screen for the "Good job!" message.<br /> 3. Ensure the message appears with a short latency (within 200ms).|    The "Good job!" message appears immediately after finishing the game.  |     TO BE TESTED.       |     Low     |
| Lane Display| Ensure the game displays correctly a lane on the screen.| 4 |    1. Start the game.<br /> 2. Observe the screen for one lane.<br /> 3. Ensure that the lane is fully rendered and clear.<br /> 4. Verify that the lane does not show any visual distortion.|    The lane is displayed fully, with no visual issues.  |     âœ…        |     Medium     |
| Road Display| Ensure the game displays correctly 5 lanes side by side on the screen, forming a road.| 4 |    1. Start the game.<br /> 2. Observe the screen for the full road display.<br /> 3. Verify that all five lanes are rendered side by side.<br /> 4. Ensure that the lanes are aligned and clear.|    The road is displayed with all five lanes, fully rendered and aligned.  |     âœ…       |     Medium     |
|Background Display| Ensure the game displays the background correctly, including textures for the grass, sidewalks, and sea, and verify that all other sprites blend well with the background.| 5 |    1. Start the game.<br /> 2. Observe the background throughout gameplay.<br /> 3. Verify that the textures for the grass, sidewalks, and sea are correctly rendered.<br /> 4. Ensure that the sprites (frog, cars, etc.) blend seamlessly with the background and do not appear out of place.<br /> 5. Check for any graphical issues or misalignment in the background textures.|    The background is displayed with properly rendered textures for the grass, sidewalks, and sea, and all sprites blend smoothly with the background.  |     âœ…        |     Low     |

### 3-6 Regression Testing

Throughout the project, we will update the game many times, and the program will be different at each use. So new problems due to the update could occur, even influencing some test cases that have been declared completed.

That's the reason we will perform bunches of testing between each update, and attempt to fix the bugs encountered after new updates.

| Bunch of testing | Date of testing | Number of tests performed |  Number of bugs found (including the tests already completed)    |    Number of tests completed|  
| --------- | ----------------- | -------------------- |    ---------------     |    --------    |
| Bunch of testing nÂ°1 | 10/18/2024  |  83   | 3 (0) | 76  |
| Bunch of testing nÂ°2 | 10/18/2024  |  84    | 4 (0)  | 81  |
| Bunch of testing nÂ°3 | 10/21/2024   |  88   | 4 (0)  | 86  |
| Bunch of testing nÂ°4 | TBD  |  TBD   | TBD  | TBD  |
| Bunch of testing nÂ°5 | TBD  |  TBD   | TBD  | TBD  |

## 4. Features to not test

Because the time granted of our project will be limited, we have no choice but to put aside some features. 

Indeed, only the 1st part of Frogger, the road, will be present to our version of the game. So any game elements related to the River zone will be ommitted, such as: 

- the floating bushes, and other moving platforms, which would allow the frog to reach the end of the level.
- the possibility to drown, if the frog misses a moving platforms, which will result to a death.
- bonuses to receive points, like a female frog hoping on the character's back, won't be present in our version.

Furthermore, we have decided to avoid to work on these features: 

- a life counter, which will display on screen the number of remaining lives, won't be added because the game will only have 1 life.
- no sound nor music will be added, because they would be hard to program and consume too much memory.
- there won't be any menu and neither a high score chart, as the game starts immediately when the program starts.
- a Game Over screen has been considered, but it won't be added.

## 5. Hardware Requirements

Since this project is programmed exclusively for the FPGA module, we will require specific hardware to upload and execute the code effectively.

First, a Go Board is essential. This board includes a USB port for connecting to a device, four switches for player movement control, two 7-segment displays to show the level counter, and a VGA connector to output the game on a computer screen. Additionally, it incorporates an FPGA chip, which is necessary for utilizing LUTs (Look-Up Tables) and Flip-Flops for logic operations.

Next, we will need either a flipbook or mapbook to carry out the project tests. The program should be compatible with both Apple and Microsoft devices to ensure cross-platform functionality.

Finally, a secondary computer will be required to display the game through a full HD VGA screen and establish a connection to the FPGA module.

## 6. Environment Requirements

A robust programming environment is crucial to conducting tests smoothly and efficiently.

To begin, we utilize VS Code for writing the program and GitHub for version control and collaboration within the team.

However, additional software tools are required for specific testing tasks. These include:

- A tool to monitor the game's framerate and overall performance
- A simulator, such as EDA Playground, to facilitate testbench execution and verify the code functionality in a controlled environment.

## 7. Problem Reporting

In case of a bug encountered, here are the following tasks to follow:

- Step 1: Describe the bug, where we examine what kind of issue it causes to our program.

- Step 2: Analyze the bug, where we write down the conditions to perform the bug.

- Step 3: Update the bug list, where we enter the causes and consequences of our bug as well as its history.

- Step 4: Perform a strategy to attempt countering the problem and fix the issue. Help from other people could be required.

- Step 5: Correct the issue, and make sure to test if the problem doesnt occur anymore.

## 8. Risks & Assumptions

| Risks | Assumptions | 
| ------| ----------- | 
| Limited time and ressources for completing test cases | Prioritize what test cases must be completed first.  |
| The game perform some crashes in some situations. | Ensure the FPGA's memory isnt overused.  |
| The VGA screen has trouble displaying some elements of the game. | Certain sprites must be simplified to use less memory as possible.  |
| Buttons may not respond consistently due to hardware bounce issues. | The debounce logic in the code is correctly implemented and tested for all buttons.  |
| Difficulty debugging hardware-specific issues (e.g., slow execution on FPGA but not in simulation). | Simulation matches the FPGA's actual behavior closely, and FPGA tools provide sufficient insight into performance issues.  |

## 9. Approvals

| Role | Name | Signature | Date |
|---|---|---|---|
| Project Manager | Laurent	BOUQUIN | âœ… | 10/18/2024 |
| Program Manager | Pavlo Prendi | TBD | TBD|
| Tech Lead | Benoit DE KEYN | TBD | TBD |
| Software Developer | Tino	GABET | TBD | TBD |
| Software Developer | Maxime THIZEAU |TBD | TBD|
