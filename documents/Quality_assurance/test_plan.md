# Test Plan 

| Author        | Paul NOWAK (Q.A.) |
|---------------|------------|
| Created       | 09/28/2024 |
| Last Modified | 10/10/2024 |
| Number of Test Cases written| 81 |
| Number of Test Cases completed| 0 |
| Document Deadline | 10/21/2024 |

---

<details>

<summary>ðŸ“– Table of content</summary>

- [Introduction](##introduction) 
- [1.Objectives](##1.objectives) 
- [2.Testing Strategy](##2.testing-strategy) 
 - [2.1.Functional Testing](###2.1.functional-testing) 
 - [2.2.Performance Testing](###2.2.performance-testing) 
 - [2.3.Stress Testing](###2.3.stress-testing) 
 - [2.4.Hardware Testing](###2.4.hardware-testing) 
 - [2.5.User Interface Testing](###2.5.user-interface-testing) 
 - [2.6.Regression Testing](###2.6.regression-testing) 
- [3.Features to test](##3.features-to-test)
 - [3.1.Functional Testing](###3.1.functional-testing) 
 - [3.2.Performance Testing](###3.2.performance-testing) 
 - [3.3.Stress Testing](###3.3.stress-testing) 
 - [3.4.Hardware Testing](###3.4.hardware-testing) 
 - [3.5.User Interface Testing](###3.5.user-interface-testing) 
 - [3.6.Regression Testing](###3.6.regression-testing) 
- [4.Features to not test](##4.features-to-not-test) 
- [5.Hardware Requirements](##5.hardware-requirements) 
- [6.Environment Requirements](##6.environment-requirements) 
- [7.Test Schedule](##7.test-schedule) 
- [8.Problem Reporting](##8.problem-reporting) 
- [9.Risks & Assumptions](##9.risks-&-assumptions) 
- [10.Approvals](##10.approvals) 

</details>

---

## Introduction

## 1.Objectives 

## 2.Testing Strategy
The test cases will be separated in 6 different domain of testing. Indeed, we want to check each type individually to ensure their performance before testing the cases together.

### 2.1.Functional Testing
Probably the most important, this first type of testing concerns the game logic: its goal is to ensure the game's functions work correctly, such as the player movements, the collisions and the reset conditions.

The testing will be executed by the Q.A., with the possible assistance of the Software Engineers and the Program Manager. In fact, the test cases will be accomplished in a way the tester is currently playing the game.

### 2.2.Performance Testing
This testing deals about the clock timing, where the game logic follows the clock cycle allowed by the FPGA module. Furthermore, it will allow to measure the latency and the refresh rate of the game.

The Q.A. and the Tech Lead will be the involved testers, where various softwares and tools would be required to measure the performance. In reality, the goal will be to test the game by monitoring the player's actions and the game's responses.

### 2.3.Stress Testing
Stress Testing is particular, because it involves inconsistent conditions such as simulating multiple inputs or slow loading conditions.

The Q.A., possibly accompanied by the Software Engineers and the Tech Lead, will work on that type of testing. For that, they will pretend to play the game in an "agressive manner" and use a software to simulate a slow latency.

### 2.4.Hardware Testing
This one will be required because it's focused on the use of the FPGA module. Indeed, we will have to make sure the module will handle the required program of the game, that its components like switches and lead still work, and potentially display the level number on his LCD screen.

The Q.A. will work on that testing with the assistance of the Tech Lead, where they will test various programs to ensure the hardware performance of the FPGA module.

### 2.5.User Interface Testing
User Interface Testing, as its name implies, deals with the interaction between the user and the game's interface. Indeed, it will test if the games responds well to the player's inputs and if the game's screen displays correctly on a monitor or another device.

Once again, the Q.A. will be in charge of the test, but with the possible assistance of the Software Engineers and the Program Manager. For that, they will execute various inputs with the keyboard and monitor differents screen settings to visualize the game.

### 2.6.Regression Testing
Finally, Regression Testing should be done after one or several others types of testing have been tested. Indeed, bugs will potentially appear, and after fixing them, there is a huge chance we will have to execute the previous test cases again to ensure their functionnality.

Every involved testers from previous testings, led by the Q.A., will be in charge with the previous rules decided for each testing.

## 3.Features to test

### 3.1.Functional Testing

#### Frogger
| Test Name | Description | Number of steps |    Steps list     |    Expected    |       Got       |       Priority       | 
| --------- | ----------------- | -------------------- |    ---------------     |    --------    |       ---       |       ---       | 
| Frog Generation | Ensures to generate the Frog at his starting point on the screen.| 3 |    1. Start the game. <br /> 2.Set a generateFrogger() signal. <br /> 3. Wait for a few clock cycles to allow the frog's generation. <br />  |    Frogger is generated at his starting point.    |     TO BE TESTED.       |     High     |
| Frog Length Movement | We set a movement input signal to make the frog move from 1 tile to another.| 5 |    1. Start the game. <br />  2. Generates the frog.  <br /> 3. Wait for a few clock cycles to allow the frog's generation. <br /> 4.Set a movement input signal. <br /> 5. Wait for a few clock cycles to allow frog's movement. <br />  |    The frog's moves by only 1 tile.    |     TO BE TESTED.       |     High     |
| Right Movement | We set a movement input signal  to make the frog go to the Right.| 5 |    1. Start the game <br />  2. Generates the frog.  <br /> 3. Wait for a few clock cycles to allow the frog's generation. <br /> 4. Set the Right Key input signal.<br /> 5. Wait for a few clock cycles to allow frog's movement.  |    The frog's moves 1 tile on the Right.    |     TO BE TESTED.       |     High     |
| Left Movement | We set a movement input signal to make the frog go to the Left.| 5 |    1. Start the game <br />  2. Generates the frog.  <br /> 3. Wait for a few clock cycles to allow the frog's generation. <br /> 4. Set the Left Key input signal. <br /> 5. Wait for a few clock cycles to allow frog's movement.  |    The frog's moves 1 tile on the Left.    |     TO BE TESTED.       |     High     |
| Up Movement | We set a movement input signal to make the frog go Up.| 5 |    1. Start the game <br />  2. Generates the frog.  <br /> 3. Wait for a few clock cycles to allow the frog's generation. <br /> 4. Set the Up Key input signal. <br /> 5. Wait for a few clock cycles to allow frog's movement. |    The frog's moves 1 tile upwards.    |     TO BE TESTED.       |     High     |
| Down Movement | We set a movement input signal to make the frog go to the Right.| 5 |    1. Start the game <br />  2. Generates the frog.  <br /> 3. Wait for a few clock cycles to allow the frog's generation. <br /> 4. Set the Down Key input signal.  <br /> 5. Wait for a few clock cycles to allow frog's movement.  |    The frog's moves 1 tile downwards.    |     TO BE TESTED.       |     High     |
| Sprite Rotation | We set a movement input signal different from the actual frog's direction to make him turn.| 5 |    1. Start the game <br />  2. Generates the frog.  <br /> 3. Wait for a few clock cycles to allow the frog's generation. <br /> 4. Set a movement input signal different from the frog's actual direction.  <br /> 5. Wait for a few clock cycles to allow frog's movement.  |    The frog's sprite is rotated in the same direction than the last movement input.    |     TO BE TESTED.       |     Medium     |
| Walking Animation | We set a movement input signal to play the frog's walking animation.| 6 |    1. Start the game <br />  2. Generates the frog.  <br /> 3. Wait for a few clock cycles to allow the frog's generation. <br /> 4. Set any movement input signal.  <br /> 5. Wait for a few clock cycles to allow frog's movement. <br /> 6. Monitor the frog's sprite behavior while the playWalkingAnimation() signal is triggered. |    The frog's moving animation is triggered.    |     TO BE TESTED.       |     Low     |

#### Cars

| Test Name | Description | Number of steps |    Steps list     |    Expected    |       Got       |       Priority       | 
| --------- | ----------------- | -------------------- |    ---------------     |    --------    |       ---       |       ---       | 
| Single Car | There should be at least on car appearing on the screen.| 3 |    1. Start the game <br /> 2. Set a generateCar() signal.  <br /> 3. Wait for a few clock cycles to allow car generation. |    A car sprite appears on the road, within 1-2 seconds of setting generateCar().   |     TO BE TESTED.       |     High     |
| Left Movement | A car moves to the left throughout a lane.| 5 |    1. Start the game <br /> 2. Set a generateCar() signal.  <br /> 3. Wait for a few clock cycles to allow car generation. <br /> 4. Set the moveCarLeft() signal. <br /> 5. Wait for a few clock cycles to allow car movement. |    A car sprite appears on the screen, within 1-2 seconds of setting generateCar(), starts moving left, and passes through its lane smoothly.   |     TO BE TESTED.       |     High     |
| Right Movement | A car moves to the right throughout a lane.| 5 |    1. Start the game <br /> 2. Set a generateCar() signal.  <br /> 3. Wait for a few clock cycles to allow car generation. <br /> 4. Set the moveCarRight() signal. <br /> 5. Wait for a few clock cycles to allow car movement. |    A car sprite appears on the screen, within 1-2 seconds of setting generateCar(), starts moving right, and passes through its lane smoothly.      |     TO BE TESTED.       |     High     |
| Driving Left Animation | We ensure the car's driving animation occurs when it is moving left.| 6 |    1. Start the game <br /> 2. Set a generateCar() signal.  <br /> 3. Wait for a few clock cycles to allow car generation. <br /> 4. Set the moveCarLeft() signal. <br /> 5. Wait for a few clock cycles to allow car movement. <br /> 6. Monitor the car's sprite behavior while the playDrivingAnimation() signal is triggered. |    The car's driving animation is triggered while moving to the left.    |     TO BE TESTED.       |     Low     |
| Driving Right Animation | We ensure the car's driving animation occurs when it is moving right.| 6 |    1. Start the game <br /> 2. Set a generateCar() signal.  <br /> 3. Wait for a few clock cycles to allow car generation. <br /> 4. Set the moveCarRight() signal. <br /> 5. Wait for a few clock cycles to allow car movement. <br /> 6. Monitor the car's sprite behavior while the playDrivingAnimation() signal is triggered. |    The car's driving animation is triggered while moving to the right.    |     TO BE TESTED.       |     Low     |
| Car Rotation | A car's sprite is rotated on the right or left depending on its movement.| 5 |    1. Start the game <br /> 2. Set a generateCar() signal.  <br /> 3. Wait for a few clock cycles to allow car generation. 4. Set a car movement input signal.  5. Wait for a few clock cycles to allow car movement.  |    A car sprite appears on the road, within 1-2 seconds of setting generateCar(), and its sprite is rotated in the same direction than its actual movement.   |     TO BE TESTED.       |     High     |
| Car Right Generation | A car appears from the right side of the road and moves to the left throughout a lane.| 5 |    1. Start the game <br /> 2. Set a generateCarFromRight() signal.  <br /> 3. Wait for a few clock cycles to allow car generation. <br /> 4. Set the moveCarLeft() signal. <br /> 5. Wait for a few clock cycles to allow car movement. |    A car sprite progressively appears from the right of the screen, within 1-2 seconds of setting generateCarFromRight(), starts moving left, and passes through its lane smoothly.   |     TO BE TESTED.       |     Medium     |
| Car Left Generation | A car appears from the left side of the road and moves to the right throughout a lane.| 5 |    1. Start the game <br /> 2. Set a generateCarFromLeft() signal.  <br /> 3. Wait for a few clock cycles to allow car generation. <br /> 4. Set the moveCarRight() signal. <br /> 5. Wait for a few clock cycles to allow car movement. |    A car sprite progressively appears from the left of the screen, within 1-2 seconds of setting generateCarFromLeft(), starts moving right, and passes through its lane smoothly.   |     TO BE TESTED.       |     Medium     |
| Car Random Generation| Ensure a car can be randomly generated in a range of locations within a lane, even at both left and right edges.| 8 |    1. Start the game <br /> 2. Set a generateCar() signal.  <br /> 3. Wait for a few clock cycles to allow car generation. <br /> 4. Monitor the location of the car's first appearance and check if its located within the range. <br /> 5. Trigger all movement signals to restart the game. <br /> 6. Make sure the all signals last for at least 2 seconds. <br /> 7. Check if the level 1 has been restarted. <br /> 8. Repeat steps 2-7 several times and make sure the previous car disappeared and replaced by another car at a random location. |    Each time the player start the level, the car is always generated at a location of a lane within the designated range.   |     TO BE TESTED.       |     Medium     |
| Car Left Disappearance | A moving car from the right progressively disappears when it reaches the left side of the screen.| 8 |    1. Start the game.<br /> 2. Set the generateCarFromRight() signal.<br /> 3. Wait for a few clock cycles to allow car generation.<br /> 4. Set the moveCarLeft() signal.<br /> 5. Wait for a few clock cycles to allow car movement.<br /> 6. Wait until the car reaches the left screen edge.<br /> 7. Set the disappearCarOnLeft() signal.<br /> 8. Wait for a few clock cycles to allow car disappearance. <br /> |    The car sprite fades or shrinks progressively until it disappears off the left side of the screen. The movement and disappearance should occur smoothly, within 1-2 seconds.   |     TO BE TESTED.       |     Medium     |
| Car Right Disappearance | A moving car from the left progressively disappears when it reaches the right side of the screen.| 8 |    1. Start the game.<br /> 2. Set the generateCarFromLeft() signal.<br /> 3. Wait for a few clock cycles to allow car generation.<br /> 4. Set the moveCarRight() signal.<br /> 5. Wait for a few clock cycles to allow car movement.<br /> 6. Wait until the car reaches the right screen edge.<br /> 7. Set the disappearCarOnRight() signal.<br /> 8. Wait for a few clock cycles to allow car disappearance. <br /> |    The car sprite fades or shrinks progressively until it disappears off the right side of the screen. The movement and disappearance should occur smoothly, within 1-2 seconds.   |     TO BE TESTED.       |     Medium     |
| Set Car speed | Permit to set a different speed to a moving car.| 6 |    1. Start the game <br /> 2. Set a generateCar() signal.  <br /> 3. Wait for a few clock cycles to allow car generation. 4. Set the movingCar() signal. 5. Set the sprite speed. 6. Wait for a few clock cycles to allow car movement. |    A car sprite appears on the road, within 1-2 seconds of setting generateCar(), and moves at the set speed.   |     TO BE TESTED.       |     High     |
| Increase Car Speed | Increases the speed of a moving car.| 7 |    1. Start the game <br /> 2. Set a generateCar() signal.  <br /> 3. Wait for a few clock cycles to allow car generation. 4. Set the movingCar() signal. 5. Wait for a few clock cycles to allow car movement. 6. Set the increaseCarSpeed() signal.  7. ait for a few clock cycles to allow speed increase. |    A car sprite appears on the road, within 1-2 seconds of setting generateCar(), and its speed is slightly increased.   |     TO BE TESTED.       |     Medium     |
| Varying Car Widths | Ensure cars can be generated with a different width (small/large).| 4 |    1. Start the game <br /> 2. Set a generateCar() signal.  <br /> 3. Set the car's width.  4. Wait for a few clock cycles to allow car generation. |    A car sprite appears on the road, within 1-2 seconds of setting generateCar(), and its sprite is as large as its set width.   |     TO BE TESTED.       |     Low     |

#### Collision

| Test Name | Description | Number of steps |    Steps list     |    Expected    |       Got       |       Priority       | 
| --------- | ----------------- | -------------------- |    ---------------     |    --------    |       ---       |       ---       | 
| Car Left Collision with Frog | Detects a collision between a car (from the left) and the frog.| 7 |    1. Start the game.<br /> 2. Generate the frog.<br /> 3. Wait for a few clock cycles to allow the frog to appear.<br /> 4. Set the generateCar() signal.<br /> 5. Wait for car generation.<br /> 6. Makes the car move right. <br /> 7. Move the frog into the carâ€™s path until they collide. <br />  |    The game triggers a car_Frog_Collision() signal when the frog collides with the car which came from the left.   |     TO BE TESTED.       |     High     |
| Car Right Collision with Frog | Detects a collision between a car (from the right) and the frog.| 7 |    1. Start the game.<br /> 2. Generate the frog.<br /> 3. Wait for a few clock cycles to allow the frog to appear.<br /> 4. Set the generateCar() signal.<br /> 5. Wait for car generation.<br /> 6. Makes the car move left. <br /> 7. Move the frog into the carâ€™s path until they collide. <br />  |    The game triggers a car_Frog_Collision() signal when the frog collides with the car which came from the right.   |     TO BE TESTED.       |     High     |
| Car Downwards Collision with Frog | Detects a collision between a car and the frog while the latter go upwards but right into a moving car.| 7 |    1. Start the game.<br /> 2. Generate the frog.<br /> 3. Wait for a few clock cycles to allow the frog to appear.<br /> 4. Set the generateCar() signal.<br /> 5. Wait for car generation.<br /> 6. Move the frog and make sure you reach a location where a moving car move in the lane above yours. <br /> 7. Make the frog go upwards at the exact moment where the car is located above it. <br />  |    The game triggers a car_Frog_Collision() signal when the frog collides with the car from below.   |     TO BE TESTED.       |     Medium     |
| Car Upwards Collision with Frog | Detects a collision between a car and the frog while the latter go downwards but right into a moving car.| 7 |    1. Start the game.<br /> 2. Generate the frog.<br /> 3. Wait for a few clock cycles to allow the frog to appear.<br /> 4. Set the generateCar() signal.<br /> 5. Wait for car generation.<br /> 6. Move the frog and make sure you reach a location where a moving car move in the lane below yours. <br /> 7. Make the frog go downwards at the exact moment where the car is located below it. <br />  |    The game triggers a car_Frog_Collision() signal when the frog collides with the car from above.   |     TO BE TESTED.       |     Medium     |
| Frog death | Trigger the death animation of the frog.| 8 |    1. Start the game.<br /> 2. Generate the frog.<br /> 3. Wait for a few clock cycles to allow the frogâ€™s generation.<br /> 4. Set the generateCar() signal.<br /> 5. Wait for car generation.<br /> 6. Trigger car_Frog_Collision() signal.<br /> 7. Stop the frog in place.<br /> 8. Play the frogâ€™s death animation. <br /> |    The frog stops moving, and the death animation plays after collision.   |     TO BE TESTED.       |     Medium     |
| No Car Collision | Prevents 2 moving cars from the same lane to collide.| 7 |    1. Start the game.<br /> 2. Set the generateCar() signal.<br /> 3. Wait for a few clock cycles for car generation.<br /> 4. Generate another car in the same lane.<br /> 5. Wait for second car generation.<br /> 6. Set the same speed and collision box for both cars.<br /> 7. Verify that both cars maintain a distance equal to their collision box without overlapping. <br />  |    The two cars move at the same speed in the lane, maintaining a distance without colliding.   |     TO BE TESTED.       |     Medium     |


#### Game Rules

| Test Name | Description | Number of steps |    Steps list     |    Expected    |       Got       |       Priority       | 
| --------- | ----------------- | -------------------- |    ---------------     |    --------    |       ---       |       ---       | 
| Frog reaches Level End | Send a Level Complete signal once the frog finished crossing the road.| 4 |    1. Start the game <br /> 2. Generate the frog.  <br /> 3. Wait for a few clock cycles to allow frog generation. <br /> 4. Move the Frog until you reaches the end of the level.<br /> |    A levelComplete() signal is sent when the frog reaches the end.   |     TO BE TESTED.       |     High     |
| Go to Next Level | Teleports the frog back to its starting point after reaching the end of the level.| 6 |    1. Start the game.<br /> 2. Generate the frog.<br /> 3. Wait for a few clock cycles to allow frog generation.<br /> 4. Move the frog to the end of the level.<br /> 5. Trigger the levelComplete() signal.<br /> 6. Wait for a few clock cycles for the frog to teleport back to the start. <br /> |    The frog sprite disappears from the end of the level and reappears at the starting position within a set number of clock cycles.   |     TO BE TESTED.       |     High     |
| Level Counter | Update the level counter by one when a level is completed.| 5 |    1. Start the game.<br /> 2. Generate the frog.<br /> 3. Wait for a few clock cycles to allow frog generation.<br /> 4. Move the frog to the end of the level.<br /> 5. Trigger the levelComplete() signal.<br />|    The Level Counter is increased by 1 on the FPGA module.   |     TO BE TESTED.       |     High     |
| Game Cleared | Display a message saying "Good Job" when the player complete all levels.| 7 |    1. Start the game. <br /> 2. Generate the frog. <br /> 3. Wait for a few clock cycles to allow frog generation. <br /> 4. Move the frog to the end of the level. <br /> 5. Trigger the levelComplete() signal. <br /> 6. Repeat the steps 2-5 until the last level is finished. <br /> 7. Send the gameCleared() signal. <br /> |    The "GOOD JOB" message is displayed.   |     TO BE TESTED.       |     Medium     |
| Score to 0 | Makes sure the score is set at 0 when a new game starts.| 2 |    1. Start the game.<br /> 2. Send a resetScore() signal.<br />|    The Score is set to 0 when we start playing.   |     TO BE TESTED.       |     Medium     |
| Score Counter | Update the Score by adding a fixed value when a level is completed.| 5 |    1. Start the game.<br /> 2. Generate the frog.<br /> 3. Wait for a few clock cycles to allow frog generation.<br /> 4. Move the frog to the end of the level.<br /> 5. Trigger the levelComplete() signal.<br />|    The Score is increased by a fixed value (e.g. 100), and the increase is reflected within a few clock cycles.   |     TO BE TESTED.       |     Medium     |
| Full Life | Makes sure the Life Counter is set to its maximum value when a new game starts.| 2 |    1. Start the game.<br /> 2. Send a resetLife() signal.<br />|    The Life Counter is set to max (e.g. 5) when we start playing.   |     TO BE TESTED.       |     Medium     |
| Life Lost | Decreases the life counter of the frog by 1 upon death.| 9 |    1. Start the game.<br /> 2. Generate the frog.<br /> 3. Wait for a few clock cycles to allow frog generation.<br /> 4. Set the generateCar() signal.<br /> 5. Wait for car generation.<br /> 6. Trigger the car_Frog_Collision() signal.<br /> 7. Stop the frog in place and play the frogâ€™s death animation. <br /> 8. Send the decreaseLife() signal and monitor the life counter. <br /> 9. Verify that the restartGame() signal is triggered and the game restarts at level 1.|    The life counter decreases by 1 after the frogâ€™s death, and the game restarts at level 1 once all lives are lost. Frog teleports back to the starting point, the level counter resets to 1, and the score resets to 0.   |     TO BE TESTED.       |     Medium     |
| All Lives Lost | Decreases the life counter of the frog repeatedly until it reaches 0.| 11 |    1. Start the game.<br /> 2. Generate the frog.<br /> 3. Wait for a few clock cycles to allow frog generation.<br /> 4. Set the generateCar() signal.<br /> 5. Wait for car generation.<br /> 6. Trigger the car_Frog_Collision() signal.<br /> 7. Stop the frog in place and play the frogâ€™s death animation.<br /> 8. Send the decreaseLife() signal and monitor the life counter.<br /> 9. Make sure the frog has respawned to its starting point. <br /> 10. Repeat steps 4-9 until the life counter reaches 0.<br /> 11. Verify that the game sends a gameOver() signal once the life counter hits 0. <br />|    The life counter decreases after each death and eventually reaches 0. When the counter reaches 0, the game sends a gameOver() signal.   |     TO BE TESTED.       |     Medium     |
| Game Over | Display a message saying "Game Over" when the player lost all of his lives and send him back to the main menu page.| 11 |    1. Start the game. <br /> 2. Generate the frog.<br /> 3. Wait for a few clock cycles to allow frog generation.<br /> 4. Set the generateCar() signal. <br /> 5. Wait for car generation. <br /> 6. Trigger the car_Frog_Collision() signal. <br /> 7. Stop the frog in place and play the frogâ€™s death animation. <br /> 8. Send the decreaseLife() signal and monitor the life counter. <br /> 9. Repeat steps 4-8 until the life counter reaches 0.<br /> 10. Sends a gameOver() signal. <br /> 11. Verify if the "Game Over" screen is displayed after a few clock cycles. <br /> 12. Type a random input. <br />|    The "GAME OVER" message is displayed until the player type an input which makes them go back to the game's menu.   |     TO BE TESTED.       |     Medium     |
| One Car per Lane | Ensure only one car can occupy a lane at any time.| 6 |    1. Start the game <br /> 2. Set a generateCar() signal.  <br /> 3. Wait for a few clock cycles to allow car generation. <br /> 4. Attempt to generate another car in the same lane.<br /> 5. Wait for a few clock cycles.<br /> 6. Verify the game prevents the second car from appearing in the same lane. <br /> |    Only one car appears in the lane, and the game prevents the second car from being generated in that lane.   |     TO BE TESTED.       |     Medium     |
| Several cars in a Lane | Ensure that several moving cars can occupy a lane at any time. Can be tested for a more challenging game.| 7 |    1. Start the game <br /> 2. Set a generateCar() signal.  <br /> 3. Wait for a few clock cycles to allow car generation. <br /> 4. Generate another car in the same lane.<br /> 5. Wait for a few clock cycles.<br /> 6. Verify the game allows the second car from appearing in the same lane. <br /> 7. Monitor the speed of each car and make sure they are similar. <br /> |    2 cars are actually moving smoothly through the same lane, in the same direction and at the same speed, one after another.   |     TO BE TESTED.       |     Low     |
| Cars Speed Increase | Increase the speed of all cars slightly when advancing to the next level.| 7 |    1. Start the game.<br /> 2. Generate the frog.<br /> 3. Wait for a few clock cycles to allow frog generation.<br /> 4. Move the frog to the end of the level.<br /> 5. Trigger the levelComplete() signal.<br /> 6. Increase the level counter by one.<br /> 7. Monitor and record the car speeds before and after the level increase. <br /> | All cars' speed increases by a fixed factor (e.g., multiplied by 1.1), and the increase is reflected within a specific number of clock cycles. |     TO BE TESTED.       |     Low     |
| Cars Number Increase | Increase the number of cars by 1 when advancing to the next level.| 7 |    1. Start the game.<br /> 2. Generate the frog.<br /> 3. Wait for a few clock cycles to allow frog generation.<br /> 4. Move the frog to the end of the level.<br /> 5. Trigger the levelComplete() signal.<br /> 6. Increase the level counter by one.<br /> 7. Monitor car lanes and ensure a new car is generated in a free lane without colliding with other cars. <br />|    A new car is generated within a free space in the lane, with a minimum distance (collision-free) from other cars, and appears within a set time frame after the level increase.   |     TO BE TESTED.       |     Low     |
| Cars Continuous Movement | Ensure that when the frog respawns (after going to the next leveol), the cars on the road continue moving smoothly.| 9 |    1. Start the game.<br /> 2. Generate the frog.<br /> 3. Wait for a few clock cycles to allow frog generation.<br /> 4. Generate multiple moving cars.<br /> 5. Wait for car generation and verify all cars are moving.<br /> 6. Move the frog to the end of the level.<br /> 7. Trigger the levelComplete() signal.<br /> 8. Increase the level counter by one.<br /> 9. Monitor the movement of cars while the frog respawns, ensuring no interruption in their motion. <br /> |    All cars continue moving without interruption throughout the level increase cycle. The frog respawns correctly, and car positions are consistent.   |     TO BE TESTED.       |     Low     |
| Game Restart | Test the ability to restart the game by sending all movement signals (Right, Left, Up, Down) simultaneously for at least 2 seconds. Verify that the game resets to level 1.| 8 |    1. Start the game. <br /> 2. Send the generateFrog() signal.  <br /> 3. Wait for a few clock cycles to allow frog generation. <br /> 4. Set a generateCar() signal.  <br /> 5. Wait for a few clock cycles to allow car generation. <br /> 6. Send a Right, Left, Up and Down signals all at the same time. <br /> 7. Monitor the signals to ensure they are held for the full 2-second duration. <br /> 8. Wait a few clock cycles before the restartGame() signal is triggered. |    The game has restarted back to level 1, where the frog has teleported back to its starting point, the level counter went back to 1, the score went back to 0, and the number of cars present in the road have decreased at its initial number.    |     TO BE TESTED.       |     High     |


### 3.2.Performance Testing

#### Frogger Performance

| Test Name | Description | Number of steps |    Steps list     |    Expected    |       Got       |       Priority       | 
| --------- | ----------------- | -------------------- |    ---------------     |    --------    |       ---       |       ---       | 
| Frog Generation Latency | Ensure the time latency between the game's launch and the frog's generation on its starting point is short (e.g. < 200 ms).| 3 |    1. Start the game <br /> 2. Set a generateFrogger() signal.  <br /> 3. Measure the number of clock cycles required to allow frog generation. <br />  |    The time required to generate the Frog on the map is short.   |     TO BE TESTED.       |     High     |
| Right Movement Latency | Ensure the frog's movement is responsive when the player presses the Right button.| 5 |    1. Start the game <br />  2. Generates the frog.  <br /> 3. Wait for a few clock cycles to allow the frog's generation. <br /> 4. Set the Right Key input signal.<br /> 5. Measure the number of clock cycles required to allow the frog's movement.  |    The time required to make the frog go right is short (e.g. < 200 ms)    |     TO BE TESTED.       |     High     |
| Left Movement Latency | Ensure the frog's movement is responsive when the player presses the Left button.| 5 |    1. Start the game <br />  2. Generates the frog.  <br /> 3. Wait for a few clock cycles to allow the frog's generation. <br /> 4. Set the Left Key input signal.<br /> 5. Measure the number of clock cycles required to allow the frog's movement.  |    The time required to make the frog go left is short (e.g. < 200 ms)    |     TO BE TESTED.       |     High     |
| Up Movement Latency | Ensure the frog's movement is responsive when the player presses the Up button.| 5 |    1. Start the game <br />  2. Generates the frog.  <br /> 3. Wait for a few clock cycles to allow the frog's generation. <br /> 4. Set the Up Key input signal.<br /> 5. Measure the number of clock cycles required to allow the frog's movement.  |    The time required to make the frog go upwards is short (e.g. < 200 ms)    |     TO BE TESTED.       |     High     |
| Down Movement Latency | Ensure the frog's movement is responsive when the player presses the Down button.| 5 |    1. Start the game <br />  2. Generates the frog.  <br /> 3. Wait for a few clock cycles to allow the frog's generation. <br /> 4. Set the Down Key input signal.<br /> 5. Measure the number of clock cycles required to allow the frog's movement.  |    The time required to make the frog go downwards is short (e.g. < 200 ms)    |     TO BE TESTED.       |     High     |
| Sprite Rotation Latency | Ensure the frog's rotation is responsive when the player presses a input direction the frog isn't facing.| 5 |    1. Start the game <br />  2. Generates the frog.  <br /> 3. Wait for a few clock cycles to allow the frog's generation. <br /> 4. Set a movement input signal different from the frog's actual direction.  <br /> 5. Measure the number of clock cycles required to allow the frog's rotation<.>.  |    The time required to make the frog rotate is short (e.g. < 200 ms)    |     TO BE TESTED.       |     High     |
| Walking Animation Latency | Ensure the frog's walking animation is responsive.| 5 |    1. Start the game <br />  2. Generates the frog.  <br /> 3. Wait for a few clock cycles to allow the frog's generation. <br /> 4. Set any movement input signal.  <br /> 5. Measure the number of clock cycles to allow the frog's walking animation.  |    The time required to play the frog's walking animation is short (e.g. < 200 ms).    |     TO BE TESTED.       |     Medium     |

#### Cars Performance

| Test Name | Description | Number of steps |    Steps list     |    Expected    |       Got       |       Priority       | 
| --------- | ----------------- | -------------------- |    ---------------     |    --------    |       ---       |       ---       | 
| Car Generation Latency | Ensure the time latency between the game's launch and the car's generation on its starting point is short (e.g. < 200 ms).| 3 |    1. Start the game <br /> 2. Set a generateCar() signal.  <br /> 3. Measure the number of clock cycles to allow car generation. |    The time required to generate the car on the map is short.   |     TO BE TESTED.       |     High     |
| Left Movement Latency | Ensure the car is moving smoothly at the left with a regular latency. | 6 |    1. Start the game <br /> 2. Set a generateCar() signal.  <br /> 3. Wait for a few clock cycles to allow car generation. <br /> 4. Set the moveCarLeft() signal. <br /> 5.Measure the clock cycles between the trigger and the car's first visible movement. <br /> 6. Record the clock cycles for each subsequent movement to ensure consistent latency between steps.|    The car moves to the left at a consistent frame rate, with each movement step occurring after an equal number of clock cycles (based on its speed). No jitter or stuttering is observed.  |     TO BE TESTED.       |     High     |
| Right Movement Latency | Ensure the car is moving smoothly at the right with consistant latency. | 6 |    1. Start the game <br /> 2. Set a generateCar() signal.  <br /> 3. Wait for a few clock cycles to allow car generation. <br /> 4. Set the moveCarRight() signal. <br /> 5. Measure the clock cycles between the trigger and the car's first visible movement. <br /> 6. Record the clock cycles for each subsequent movement to ensure consistent latency between steps.|    The car moves to the right at a consistent frame rate, with each movement step occurring after an equal number of clock cycles (based on its speed). No jitter or stuttering is observed.  |     TO BE TESTED.       |     High     |
| Driving Left Animation Latency | Ensure the car's driving animation while moving on the left is responsive.| 6 |    1. Start the game <br /> 2. Set a generateCar() signal.  <br /> 3. Wait for a few clock cycles to allow car generation. <br /> 4. Set the moveCarLeft() signal. <br /> 5. Wait for a few clock cycles to allow car movement. <br /> 6. Measure the number of clock cycles to allow the car's driving animation. |    The time required to play the car's driving animation while moving on the left is short (e.g. < 200 ms).    |     TO BE TESTED.       |     Low     |
| Driving Right Animation Latency | Ensure the car's driving animation while moving on the right is responsive.| 6 |    1. Start the game <br /> 2. Set a generateCar() signal.  <br /> 3. Wait for a few clock cycles to allow car generation. <br /> 4. Set the moveCarRight() signal. <br /> 5. Wait for a few clock cycles to allow car movement. <br /> 6. Measure the number of clock cycles to allow the car's driving animation. |    The time required to play the car's driving animation while moving on the right is short (e.g. < 200 ms).    |     TO BE TESTED.       |     Low     |
| Car Right Generation Latency | Ensure the car is smoothly appearing from the right side of the road and moves to the left with consistant latency.| 6 |    1. Start the game <br /> 2. Set a generateCarFromRight() signal.  <br /> 3. Wait for a few clock cycles to allow car generation. <br /> 4. Set the moveCarLeft() signal. <br /> 5. Measure the number of clock cycles between the trigger and the car's first visible movement. <br /> 6. Record the clock cycles for each subsequent movement to ensure consistent latency between steps. |    The car appears on the right and moves to the left at a consistent frame rate, with each movement step occurring after an equal number of clock cycles (based on its speed). No jitter or stuttering is observed.    |     TO BE TESTED.       |     Medium     |
| Car Left Generation Latency | Ensure the car is smoothly appearing from the left side of the road and moves to the right with consistant latency.| 6 |    1. Start the game <br /> 2. Set a generateCarFromLeft() signal.  <br /> 3. Wait for a few clock cycles to allow car generation. <br /> 4. Set the moveCarRight() signal. <br /> 5. Measure the number of clock cycles between the trigger and the car's first visible movement. <br /> 6. Record the clock cycles for each subsequent movement to ensure consistent latency between steps. |    The car appears on the left and moves to the right at a consistent frame rate, with each movement step occurring after an equal number of clock cycles (based on its speed). No jitter or stuttering is observed.    |     TO BE TESTED.       |     Medium     |
| Car Left Disappearance Latency | Ensure a car coming from the right is smoothly disappearing when it reaches the left side of the screen with constant latency.| 9 |    1. Start the game.<br /> 2. Set the generateCarFromRight() signal.<br /> 3. Wait for a few clock cycles to allow car generation.<br /> 4. Set the moveCarLeft() signal.<br /> 5. Wait for a few clock cycles to allow car movement.<br /> 6. Wait until the car reaches the left screen edge.<br /> 7. Set the disappearCarOnLeft() signal.<br /> 8. Measure the number of clock cycles between the trigger and the car's visible disappearance. <br /> 9. Record the clock cycles for each subsequent movement to ensure consistent latency between steps.|    The car that came from the right is fading on the left at a consistent frame rate, with each movement step occurring after an equal number of clock cycles (based on its speed). No jitter or stuttering is observed.   |     TO BE TESTED.       |     Medium     |
| Car Right Disappearance Latency | Ensure a car coming from the left is smoothly disappearing when it reaches the right side of the screen with constant latency.| 9 |    1. Start the game.<br /> 2. Set the generateCarFromLeft() signal.<br /> 3. Wait for a few clock cycles to allow car generation.<br /> 4. Set the moveCarRight() signal.<br /> 5. Wait for a few clock cycles to allow car movement.<br /> 6. Wait until the car reaches the right screen edge.<br /> 7. Set the disappearCarOnRight() signal.<br /> 8. Measure the number of clock cycles between the trigger and the car's visible disappearance. <br /> 9. Record the clock cycles for each subsequent movement to ensure consistent latency between steps.|    The car that came from the left is fading on the right at a consistent frame rate, with each movement step occurring after an equal number of clock cycles (based on its speed). No jitter or stuttering is observed.   |     TO BE TESTED.       |     Medium     |
| Speed Increase Latency | Ensure a car's speed is responsive when we trigger the speed increase.| 8 |    1. Start the game. <br /> 2. Set a generateCar() signal.  <br /> 3. Wait for a few clock cycles to allow car generation. 4. Set the movingCar() signal. <br /> 5. Wait for consistent movement (several clock cycles). <br /> 6. Trigger increaseCarSpeed() to request a speed increase. <br /> 7. Measure the number of clock cycles between the speed increase trigger and when the car's movement reflects the speed change. <br /> 8. Record the clock cycles for each subsequent movement step to verify consistent and reduced latency after the speed increase. |    The speed increase is applied within a short time (e.g., less than 200ms). After the speed change, the car moves to the left with reduced but consistent frame intervals (i.e., the number of clock cycles per movement step decreases, but steps remain evenly spaced). No jitter or stutter is observed.   |     TO BE TESTED.       |     Medium     |
| Speed Increase Influence | Check if increasing the speed of a car causes any frame drops or slowdowns.| 8 |    1. Start the game. <br /> 2. Set a generateCar() signal.  <br /> 3. Wait a few clock cycles for car generation. 4.  Trigger moveCarLeft() to initiate car movement. <br /> 5. Allow a few clock cycles to establish normal movement. <br /> 6. Trigger the increaseCarSpeed() signal. <br /> 7. Monitor the car's speed increase and the game's frame rate after the speed change. <br /> 8. Track whether the game's frame rate or the carâ€™s movement speed experiences any drops, slowdowns, or irregularities post-speed increase. |    No frame drops or slowdowns are observed after the speed increase. The car continues to move smoothly, with faster but consistently spaced movement steps.   |     TO BE TESTED.       |     Medium     |
| Cars Number Increase Latency| Ensure the number of cars in game is responsive when trigger the number of cars increase by 1.| 9 |    1. Start the game.<br /> 2. Generate the frog.<br /> 3. Wait for a few clock cycles to allow frog generation.<br /> 4. Move the frog to the end of the level.<br /> 5. Trigger the levelComplete() signal.<br /> 6. Increase the level counter by one.<br /> 7. Trigger the addNewCar() to request an additional car. <br /> 8. Measure the number of clock cycles between the trigger and when the total of cars in game reflect the car number's change. <br/ > 9. Record the clock cycles of the new car for each subsequent movement step to verify consistent and reduced latency after the car number increase. |    The car number increase is applied within a short time (e.g., less than 200ms). After the change, the new car is moving in its lane with a consistent frame intervals. No jitter or stutter is observed.    |     TO BE TESTED.       |     Medium     |
| Car Number Increase Influence | Check if increasing the number of cars causes any frame drops or slowdowns.| 10 |     1. Start the game.<br /> 2. Generate the frog.<br /> 3. Wait for a few clock cycles to allow frog generation.<br /> 4. Move the frog to the end of the level.<br /> 5. Trigger the levelComplete() signal.<br /> 6. Increase the level counter by one.<br /> 7. Trigger the addNewCar() to request an additional car. <br /> 8. Monitor the car number and the game's framerate after the car number change. <br /> 9. Track whether the game's frame rate or the any of the car's framerate experiences any drops, slowdowns, or irregularities post-number increase. <br /> 10. Repeat the steps 2-9 until there are 6 cars to measure the game's and all car's framerate after each car number change. |    No frame drops or slowdowns are observed after each car number increase. Each car continues to move smoothly.   |     TO BE TESTED.       |     Medium     |

#### Collision Performance

| Test Name | Description | Number of steps |    Steps list     |    Expected    |       Got       |       Priority       | 
| --------- | ----------------- | -------------------- |    ---------------     |    --------    |       ---       |       ---       | 
| Car Collision with Frog Latency | Ensure the time latency between the actual car-frog collision  and the collision signal trigger is short (e.g. < 200 ms).| 8 |    1. Start the game.<br /> 2. Generate the frog.<br /> 3. Wait for a few clock cycles to allow the frog to appear.<br /> 4. Set the generateCar() signal.<br /> 5. Wait for car generation.<br /> 6. Move the frog into the carâ€™s path until they collide  (test left, right, upwards, and downwards collisions).. <br /> 7. Measure the clock cycles between the actual in-game collision and the triggering of the car_Frog_Collision() signal. <br /> 8. Verify if the frog stops immediately after the collision (visual confirmation). |  The time between the in-game car-frog collision and the car_Frog_Collision() signal trigger is short, ideally less than 200ms (or a specific number of clock cycles). The frog stops in place immediately after the collision, with no delay.   |     TO BE TESTED.       |     High     |
| Car Collision with Frog Latency (High Speed Version) | Ensure that even when the car is moving faster, the system still detects the collision precisely when the frog and car intersect.| 11 |    1. Start the game.<br /> 2. Generate the frog.<br /> 3. Wait for a few clock cycles to allow the frog to appear.<br /> 4. Set the generateCar() signal.<br /> 5. Wait for car generation.<br /> 6. Move the frog into the carâ€™s path until they collide. <br /> 7. Measure the clock cycles between the actual in-game collision and the triggering of the car_Frog_Collision() signal. <br /> 8. Verify if the frog stops immediately after the collision (visual confirmation). <br /> 9. Check if the frog respawns at its starting point. <br /> 10. Monitor whether the game restarts at level 1 when a life is lost. <br /> 11. Ensure each car's speed has been increased at the new level. <br />|   Collision detection remains accurate even at higher speeds. The car_Frog_Collision() signal triggers within 200ms (or a specific number of clock cycles). The frog stops immediately on collision with no delay, and no collisions are missed.  The game restarts at level 1 when all lives are lost.   |     TO BE TESTED.       |     Medium     |
| Frog Common Death Influence | Check if after each of the frog's death,  there is any frame drops or slowdowns among the frog, the cars or the game itself.| 14 |    1. Start the game.<br /> 2. Generate the frog.<br /> 3. Wait for a few clock cycles to allow the frog to appear.<br /> 4. Set the generateCar() signal.<br /> 5. Wait for car generation.<br /> 6. Move the frog into the carâ€™s path until they collide. <br /> 7. Measure the clock cycles between the actual in-game collision and the triggering of the car_Frog_Collision() signal. <br /> 8. Verify if the frog stops immediately after the collision (visual confirmation). <br /> 9. Check if the frog respawns at its starting point. <br /> 10. After respawn, monitor the framerate of the game, frog, and cars to detect any frame drops or slowdowns. <br /> 11. Track whether the gameâ€™s frame rate, the frogâ€™s framerate, or any carâ€™s framerate experiences drops or slowdowns. <br /> 12. Complete the level and verify the frog is teleported to its starting point at the next level. <br /> 13. Ensure car speeds increase with the new level. <br /> 14. Repeat steps 6â€“13 until no lives remain. <br /> |    After each frog death and respawn, no significant frame drops or slowdowns occur. The game, frog, and cars continue running at their expected speeds and framerates with no visual or performance degradation.   |     TO BE TESTED.       |     Medium     |
| Frog Death Animation Latency | Ensure the frog's death animation is responsive.| 8 |    1. Start the game.<br /> 2. Generate the frog.<br /> 3. Wait for a few clock cycles to allow the frogâ€™s generation.<br /> 4. Set the generateCar() signal.<br /> 5. Wait for car generation.<br /> 6. Trigger car_Frog_Collision() signal.<br /> 7. Measure the number of clock cycles between the collision signal and the start of the frogâ€™s death animation. <br /> 8. Confirm that the frog's death animation starts and runs smoothly without delay.|    The frogâ€™s death animation starts promptly (e.g., within 200ms or a specific number of clock cycles) after the collision signal. The animation runs smoothly without delay or stuttering.   |     TO BE TESTED.       |     Medium     |


#### Game Rules Performance

| Test Name | Description | Number of steps |    Steps list     |    Expected    |       Got       |       Priority       | 
| --------- | ----------------- | -------------------- |    ---------------     |    --------    |       ---       |       ---       | 
| Frog Respawn Latency | Ensure the time latency between the frog's death and its respawn at the starting point is short (e.g., < 200 ms).| 8 |    1. Start the game <br /> 2. Set a generateFrogger() signal.  <br /> 3. Move the frog into the path of a moving car to trigger a collision. <br /> 4. Upon collision, stop the frog and trigger the frog's death animation (ensure the frog has at least one remaining life). <br /> 5. Send a frogRespawn() signal once the death animation finishes. <br /> 6. Measure the number of clock cycles or time between the frogRespawn() signal and the frog's actual appearance at its starting point. <br /> 7. Track the framerate of the game during this process to ensure no slowdowns occur during respawn. <br /> 8. Ensure the frog appears smoothly at the starting point without  glitches or delays. |  The time required to respawn the frog after death should be less than 200 ms (or a pre-defined acceptable threshold), with no frame drops or slowdowns during the respawn process. The frog should reappear smoothly at the starting point, and the game should continue running at a consistent frame rate.   |     TO BE TESTED.       |     Medium     |
| Frog Next Level Latency | Ensure the time latency between the frog's arrival to the end of the level and its respawn at the starting point for the next level is short (e.g., < 200 ms).| 8 |    1. Start the game. <br /> 2. Set a generateFrogger() signal.  <br /> 3. Move the frog until it reaches the end of the level. <br /> 4. Trigger the levelComplete() signal. <br /> 5. Measure the number of clock cycles or time between the frogRespawn() signal and the frog's actual appearance at its starting point. <br /> 6. Track the framerate of the game during this process to ensure no slowdowns occur during respawn. <br /> 7. Ensure the frog appears smoothly at the starting point without glitches or delays. | The time required to respawn the frog after a level is completed should be less than 200 ms (or a pre-defined acceptable threshold), with no frame drops or slowdowns during the respawn process. The frog should reappear smoothly at the starting point, and the game should continue running at a consistent frame rate.   |     TO BE TESTED.       |     Medium     |
| Frog Level Progress Influence| Check if after each level passed, there is any frame drops or slowdowns among the frog, the cars or the game itself, especially when car speeds increase.| 8 |    1. Start the game. <br /> 2. Set a generateFrogger() signal.  <br /> 3. Move the frog until it reaches the end of the level. <br /> 4. Trigger the levelComplete() signal. <br /> 5.Increase the car speeds according to the level-up logic. <br /> 6. Measure the number of clock cycles or time between the frogRespawn() signal and the frog's actual appearance at its starting point. <br /> 7. Track the framerate of the game, including the frog and cars, during this process to ensure no slowdowns occur during respawn or car speed increases. <br /> 8. Ensure the frog and cars continue moving at their expected speeds and framerates with no frame drops or glitches. <br /> 9. Repeat the steps 3-8 until you finish last level (e.g. level 8). |    After each level is passed and car speeds increase, no significant frame drops or slowdowns occur. The game, frog, and cars run smoothly at their expected speeds and framerates with no performance degradation.   |     TO BE TESTED.       |     Medium     |
| Game Restart Latency| Ensure the time latency between the triggering of all movement signals (Right, Left, Up, Down) simultaneously for at least 2 seconds and the trigger of the restartGame() signal is short (e.g., < 200 ms).| 8 |    1. Start the game. <br /> 2. Send the generateFrog() signal.  <br /> 3. Wait for a few clock cycles to allow frog generation. <br /> 4. Set a generateCar() signal.  <br /> 5. Wait for a few clock cycles to allow car generation. <br /> 6. Send a Right, Left, Up and Down signals all at the same time. <br /> 7. Measure the time (or clock cycles) between the end of the 2-second duration and the restartGame() signal.<br /> 8. Measure the time until the frog teleports back to the starting position and the game resets to level 1. |    The game restarts with minimal latency (e.g., < 200 ms). The frog teleports back to the starting position, the level resets to 1, the score resets to 0, and the number of cars is reset to the initial value.    |     TO BE TESTED.       |     High     |
| Game Cleared Latency| Ensure the time latency between the levelComplete() signal trigger and the displaying of the "Good Job" message is short (e.g. < 200 ms).| 8 |    1. Start the game. <br /> 2. Generate the frog. <br /> 3. Wait for a few clock cycles to allow frog generation. <br /> 4. Move the frog to the end of the level. <br /> 5. Trigger the levelComplete() signal. <br /> 6. Repeat the steps 2-5 until the last level is finished. <br /> 7. Send the gameCleared() signal. <br /> 8. Monitor the number of clock between the signal trigger and when the message starts being displayed.|    The message is displayed with minimum latency.   |     TO BE TESTED.       |     Low     |
| Score to 0 Latency| Ensure the latency between the beginning of the game and the score being set at 0 is short (e.g. < 200 ms).| 2 |    1. Start the game.<br /> 2. Send a resetScore() signal.<br /> 3. Monitor the number of clock between the signal trigger and when the score is shown being reset to 0.|    The Score is set to 0 with a short latency.   |     TO BE TESTED.       |     Medium     |
| Score Counter Latency | Ensure the score is updated with a short latency (e.g. < 200 ms) when a level is completed.| 6 |    1. Start the game.<br /> 2. Generate the frog.<br /> 3. Wait for a few clock cycles to allow frog generation.<br /> 4. Move the frog to the end of the level.<br /> 5. Trigger the levelComplete() signal.<br /> 6. Monitor the number of clock between the signal trigger and when the score is updated on screen.|    The score increase latency is short.   |     TO BE TESTED.       |     Medium     |
| Level Counter Latency | Ensure the level counter is updated with a short latency (e.g. < 200 ms) when a level is completed.| 5 |    1. Start the game.<br /> 2. Generate the frog.<br /> 3. Wait for a few clock cycles to allow frog generation.<br /> 4. Move the frog to the end of the level.<br /> 5. Trigger the levelComplete() signal.<br /> 6. Monitor the number of clock between the signal trigger and when the level counter is updated on the FPGA module. |    The Level Counter increase latency is short.   |     TO BE TESTED.       |     High     |
| Full Life Latency| Ensure the latency between the beginning of the game and the life counter being set at maximum (e.g. 5) is short (e.g. < 200 ms).| 2 |    1. Start the game.<br /> 2. Send a resetLife() signal.<br /> 3. Monitor the number of clock between the signal trigger and when the life counter is shown being reset to its maximum value. |   The Life Counter is set to its maximum value with a short latency.   |     TO BE TESTED.       |     Medium     |
| Life Lost Latency| Ensure the life counter is updated with a short latency (e.g. < 200 ms) when the frog loses a life.| 9 |    1. Start the game.<br /> 2. Generate the frog.<br /> 3. Wait for a few clock cycles to allow frog generation.<br /> 4. Set the generateCar() signal.<br /> 5. Wait for car generation.<br /> 6. Trigger the car_Frog_Collision() signal.<br /> 7. Stop the frog in place and play the frogâ€™s death animation. <br /> 8. Send the decreaseLife() signal. <br /> 9. Monitor the number of clocks between the signal trigger and when the life counter is shown being updated?|    The Life Counter's decrease latency is short.   |     TO BE TESTED.       |     Medium     |
| Frog Multiple Deaths Influence | Check if after each death occured, there is any frame drops or slowdowns among the frog, the cars or the game itself.| 11 |    1. Start the game.<br /> 2. Generate the frog.<br /> 3. Wait for a few clock cycles to allow frog generation.<br /> 4. Set the generateCar() signal.<br /> 5. Wait for car generation.<br /> 6. Trigger the car_Frog_Collision() signal.<br /> 7. Stop the frog in place and play the frogâ€™s death animation.<br /> 8. Send the decreaseLife() signal and monitor the life counter.<br /> 9. Measure the number of clock cycles or time between the frogRespawn() signal and the frog's actual appearance at its starting point. <br /> 10. Track the framerate of the game during this process to ensure no slowdowns occur during respawn. <br /> 11. Repeat steps 4-8 until the life counter reaches 0.<br /> |    After each death and and each time the frog respawned, no significant frame drops or slowdowns occur. The game, frog, and cars continue running at their expected speeds and framerates with no visual or performance degradation.   |     TO BE TESTED.       |     Medium     |
| Game Over Latency | Ensure the latency between the gameOver() signal trigger and the displaying of the message "Game Over" is short.| 12 |    1. Start the game. <br /> 2. Generate the frog.<br /> 3. Wait for a few clock cycles to allow frog generation.<br /> 4. Set the generateCar() signal. <br /> 5. Wait for car generation. <br /> 6. Trigger the car_Frog_Collision() signal. <br /> 7. Stop the frog in place and play the frogâ€™s death animation. <br /> 8. Send the decreaseLife() signal and monitor the life counter. <br /> 9. Make sure the frog respawns in its starting point. <br /> 10. Repeat steps 4-9 until the life counter reaches 0.<br /> 11. Sends a gameOver() signal. <br /> 12. Measure the number of clock between the signal trigger and the displaying of the "Game Over" message. <br /> |    The "GAME OVER" message is displayed with a short latency (e.g. < 200ms)   |     TO BE TESTED.       |     Medium     |
| Return to Menu Latency | Ensure the latency between the returnMenu() signal trigger and the return in the menu after the message "Game Over" is short (e.g. < 200 ms).| 12 |    1. Start the game. <br /> 2. Generate the frog.<br /> 3. Wait for a few clock cycles to allow frog generation.<br /> 4. Set the generateCar() signal. <br /> 5. Wait for car generation. <br /> 6. Trigger the car_Frog_Collision() signal. <br /> 7. Stop the frog in place and play the frogâ€™s death animation. <br /> 8. Send the decreaseLife() signal and monitor the life counter. <br /> 9. Make sure the frog respawns in its starting point. <br /> 10. Repeat steps 4-9 until the life counter reaches 0.<br /> 11. Sends a gameOver() signal. <br /> 12. Ensure the "Game Over" message is displayed. <br /> 13. Press any input on the keyboard to trigger the returnMenu() signal. <br /> 14. Measure the number of clock between the signal trigger and the actual return to the menu. |    The player goes back to the menu after pressing an input with a short latency.  |     TO BE TESTED.       |     Low     |
| Cars Continuous Movement Influence | Measure the latency and framerate consistency of cars during the frog respawn phase (after moving to the next level), ensuring cars move without interruption.| 10 |    1. Start the game.<br /> 2. Generate the frog.<br /> 3. Wait for a few clock cycles to allow frog generation.<br /> 4. Trigger multiple generateCar() signals to produce moving cars.<br /> 5. Wait for car generation and verify that all cars are moving smoothly.<br /> 6. Move the frog to the end of the level.<br /> 7. Trigger the levelComplete() signal.<br /> 8. Increase the level counter by one.<br /> 9. Monitor the carsâ€™ motion during the frog respawn process. <br /> 10. Measure the framerate and latency of car movement during this phase, ensuring no slowdowns or interruptions.|    Car motion remains smooth, and no frame drops or slowdowns are detected. The latency between the frog respawn and car motion continuity is minimal (e.g., < 100 ms). Car positions remain consistent during and after the frog respawn.   |     TO BE TESTED.       |     Low     |

### 3.3.Stress Testing

Check for performance degradation when cars appear in large numbers (max load on cars).

Ensuring that even under heavy car generation, random positioning still happens without delay.

Check what happaned when the frog hits a moving cars from its back + performance.

### 3.4.Hardware Testing

### 3.5.User Interface Testing

### 3.6.Regression Testing

## 4.Features to not test

## 5.Hardware Requirements

## 6.Environment Requirements

## 7.Test Schedule

## 8.Problem Reporting

## 9.Risks & Assumptions

## 10.Approvals